type Diamond @entity {
  id: ID! # Diamond address
  diamondType: String! # WALLET, OFFERING, TOKEN
  creator: Bytes!
  createdAt: BigInt!
  createdTx: Bytes!
  
  # Polymorphic relationships (optional - diamonds may be tracked separately)
  wallet: Wallet
  offering: Offering
  token: Token # Can reference any token type via interface
  
  # Access control
  userRoles: [UserRole!]! @derivedFrom(field: "diamond")
}

# Generic access control tracking for all diamonds
type UserRole @entity {
  id: ID! # diamond-user-role (e.g., "0x123...abc-0x456...def-1")
  diamond: Diamond!
  user: Bytes!
  role: Int! # uint8 role ID
  enabled: Boolean!
  grantedAt: BigInt!
  grantedTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

type FunctionAccess @entity {
  id: ID! # diamond-functionSelector-role (e.g., "0x123...abc-0x12345678-1")
  diamond: Diamond!
  functionSelector: Bytes! # bytes4 function selector
  role: Int! # uint8 role ID
  hasAccess: Boolean! # true if role has access, false if revoked
  grantedAt: BigInt!
  grantedTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

type Wallet @entity {
  id: ID! # Wallet address
  type: String! # "EOA", "Passkey", "MPC"
  deployer: Bytes! # Address that deployed the wallet
  createdAt: BigInt!
  createdTx: Bytes!
  
  # Owners (multiple allowed)
  owners: [Owner!]! @derivedFrom(field: "wallet")
  
  # Documents
  documents: [Document!]! @derivedFrom(field: "wallet")
  
  # Relationships
  tokens: [Lot!]! @derivedFrom(field: "owner")
  investments: [Investment!]! @derivedFrom(field: "investor")
  kycStatus: KYCStatus
  classifications: [InvestorClassification!]! @derivedFrom(field: "wallet")
}

type Owner @entity {
  id: ID! # wallet-address or wallet-publicKeyHash
  wallet: Wallet!
  ownerType: OwnerType!
  address: Bytes # For EOA and MPC owners
  publicKey: Bytes # For Passkey owners (64 bytes: x + y coordinates)
  publicKeyHash: Bytes # For Passkey owners (hash for indexing)
  addedAt: BigInt!
  addedTx: Bytes!
}

enum OwnerType {
  EOA
  Passkey
  MPC
}

type Document @entity {
  id: ID! # Raw documentId (bytes32 as hex string)
  wallet: Wallet!
  contentHash: Bytes!
  storageURI: String!
  category: String!
  title: String!
  creator: Bytes!
  createdAt: BigInt!
  createdTx: Bytes!
  requiredSigners: [Bytes!]!
  
  # Parent-child relationship for template-based documents
  parentDocument: Document # Reference to template document (null if this is a template)
  childDocuments: [Document!]! @derivedFrom(field: "parentDocument") # Documents created from this template
  
  # Signatures
  signatures: [DocumentSignature!]! @derivedFrom(field: "document")
}

type DocumentSignature @entity {
  id: ID! # tx-hash-logIndex
  document: Document # Nullable to handle cases where DocumentSigned event is indexed before DocumentCreated
  signer: Bytes!
  signedAt: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
  logIndex: BigInt!
}

# ============ PAYMASTER ENTITIES ============

type PaymasterPolicy @entity {
  id: ID! # Wallet address
  wallet: Wallet!
  enabled: Boolean!
  dailyBudget: BigInt!
  paymasterAddress: Bytes!
  
  # Policy configuration history
  configurations: [PaymasterPolicyConfiguration!]! @derivedFrom(field: "policy")
  
  # Role policies
  rolePolicies: [RolePolicy!]! @derivedFrom(field: "policy")
  
  # Spending tracking
  sponsoredTransactions: [SponsoredTransaction!]! @derivedFrom(field: "entityPolicy")
  totalSponsored: BigInt!
  
  updatedAt: BigInt!
  updatedTx: Bytes!
}

type PaymasterPolicyConfiguration @entity {
  id: ID! # tx-hash-logIndex
  policy: PaymasterPolicy!
  enabled: Boolean!
  dailyBudget: BigInt!
  paymasterAddress: Bytes!
  timestamp: BigInt!
  tx: Bytes!
}

type RolePolicy @entity {
  id: ID! # wallet-address-role
  policy: PaymasterPolicy!
  role: Int!
  canBeSponsored: Boolean!
  dailyLimit: BigInt!
  allowedOperations: [Bytes!]!
  updatedAt: BigInt!
  updatedTx: Bytes!
}

type SponsoredTransaction @entity {
  id: ID! # tx-hash-logIndex
  entityPolicy: PaymasterPolicy!
  entity: Bytes! # Entity wallet address
  user: Bytes! # User who was sponsored
  actualCost: BigInt! # Gas cost in wei
  refunded: BigInt! # Amount refunded to paymaster
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

type PaymasterDeposit @entity {
  id: ID! # tx-hash-logIndex
  entity: Bytes!
  amount: BigInt!
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

type PaymasterWithdrawal @entity {
  id: ID! # tx-hash-logIndex
  entity: Bytes!
  recipient: Bytes!
  amount: BigInt!
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

type PolicyCheckFailure @entity {
  id: ID! # tx-hash-logIndex
  entity: Bytes!
  user: Bytes!
  reason: String!
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

# ============ VEHICLE (SPV/Fund) ENTITIES ============

type Vehicle @entity {
  id: ID! # Vehicle wallet address
  wallet: Wallet! # The wallet that has vehicle facets
  vehicleType: VehicleType! # SPV, FUND, DAO
  
  # Capital accounting totals
  totalCapitalContributed: BigInt!
  totalDistributionsExecuted: BigInt!
  totalDistributionsClaimed: BigInt!
  
  # Token reference (for unit interest tokens)
  token: Token # The UNIT_INTEREST token representing ownership
  
  # Member tracking
  memberCount: Int!
  members: [VehicleMember!]! @derivedFrom(field: "vehicle")
  
  # Capital contributions
  contributions: [CapitalContribution!]! @derivedFrom(field: "vehicle")
  
  # Distributions
  distributions: [Distribution!]! @derivedFrom(field: "vehicle")
  
  # Investments (if SPV)
  investments: [VehicleInvestment!]! @derivedFrom(field: "vehicle")
  
  createdAt: BigInt!
  createdTx: Bytes!
}

enum VehicleType {
  SPV        # Special Purpose Vehicle (single investment)
  FUND       # Multi-investment fund
  DAO        # DAO LLC
}

type VehicleMember @entity {
  id: ID! # vehicle-member-address
  vehicle: Vehicle!
  memberAddress: Bytes!
  
  # Capital accounting for this member
  capitalContributed: BigInt!
  distributionsReceived: BigInt!
  
  # Token ownership (derived from lots)
  tokenBalance: BigInt! # Current token balance
  
  addedAt: BigInt!
  addedTx: Bytes!
  
  # Track if member has been removed
  removed: Boolean!
  removedAt: BigInt
  removedTx: Bytes
  
  # Contributions by this member
  contributions: [CapitalContribution!]! @derivedFrom(field: "member")
}

type CapitalContribution @entity {
  id: ID! # tx-hash-logIndex
  vehicle: Vehicle!
  member: VehicleMember!
  memberAddress: Bytes! # Denormalized for filtering
  amount: BigInt!
  
  # Context: where did this capital come from?
  source: CapitalSource! # OFFERING, DIRECT, TRANSFER
  offering: Offering # If source = OFFERING, reference the offering
  
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
  logIndex: BigInt!
}

enum CapitalSource {
  OFFERING   # From countersigned investment in an offering
  DIRECT     # Manually recorded contribution
  TRANSFER   # From token transfer (secondary market)
}

type Distribution @entity {
  id: ID! # vehicle-distributionId
  vehicle: Vehicle!
  distributionId: BigInt! # Protocol's internal distribution ID
  totalAmount: BigInt!
  lpAmount: BigInt! # Amount for limited partners (token holders)
  carryAmount: BigInt! # Amount for carry recipients (GP, etc.)
  
  # State
  finalized: Boolean!
  finalizedAt: BigInt
  finalizedTx: Bytes
  
  createdAt: BigInt!
  createdTx: Bytes!
  blockNumber: BigInt!
  
  # Individual distributions to members
  claims: [DistributionClaim!]! @derivedFrom(field: "distribution")
}

type DistributionClaim @entity {
  id: ID! # distribution-member-address
  distribution: Distribution!
  member: VehicleMember!
  memberAddress: Bytes! # Denormalized for filtering
  amount: BigInt!
  
  # State
  claimed: Boolean!
  claimedAt: BigInt
  claimedTx: Bytes
}

type VehicleInvestment @entity {
  id: ID! # vehicle-investmentId
  vehicle: Vehicle!
  investmentId: BigInt! # Protocol's internal investment ID
  assetType: VehicleAssetType!
  
  # Investment details
  target: Bytes! # Address of the investment target (company, protocol, etc.)
  amount: BigInt!
  entryDate: BigInt!
  entryTx: Bytes!
  
  # Exit details (if exited)
  exited: Boolean!
  exitAmount: BigInt
  exitDate: BigInt
  exitTx: Bytes
  
  # Current valuation (updated by vehicle admin)
  currentValuation: BigInt!
  lastValuationUpdate: BigInt!
}

enum VehicleAssetType {
  EQUITY        # Equity investment in a company
  DEBT          # Debt instrument
  CRYPTO        # Cryptocurrency holding
  DEFI          # DeFi protocol position (e.g., Morpho)
  REAL_ESTATE   # Real estate holding
  OTHER         # Other asset types
}

# Track NAV updates for the vehicle
type VehicleValuation @entity {
  id: ID! # tx-hash-logIndex
  vehicle: Vehicle!
  totalNAV: BigInt! # Net Asset Value
  navPerToken: BigInt! # NAV divided by total token supply
  
  # Breakdown
  totalAssets: BigInt!
  totalLiabilities: BigInt!
  
  updatedBy: Bytes!
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

# Unified Activity Feed
type Activity @entity {
  id: ID! # tx-hash-logIndex or unique identifier
  type: ActivityType!
  wallet: Bytes! # The wallet this activity relates to (for filtering)
  timestamp: BigInt! # Universal timestamp for sorting
  tx: Bytes!
  blockNumber: BigInt!
  
  # Polymorphic references (only one will be set based on type)
  investment: Investment
  offering: Offering
  corporateAction: CorporateAction
  documentSignature: DocumentSignature
  document: Document
  offeringDocumentSignature: OfferingDocumentSignature
  kycStatus: KYCStatus
  classification: InvestorClassification
  lot: Lot
  attestation: Attestation # Hybrid EAS support - kept for backward compatibility
}

enum ActivityType {
  INVESTMENT_MADE
  INVESTMENT_RECEIVED
  INVESTMENT_COUNTERSIGNED
  INVESTMENT_REJECTED
  OFFCHAIN_INVESTMENT_RECORDED
  OFFCHAIN_INVESTMENT_CONFIRMED
  OFFCHAIN_INVESTMENT_CANCELLED
  OFFERING_CREATED
  OFFERING_COMPLETED
  OFFERING_CANCELLED
  CORPORATE_ACTION
  DOCUMENT_SIGNED
  DOCUMENT_UPLOADED
  KYC_STATUS_UPDATED
  KYC_REVOKED
  CLASSIFICATION_UPDATED
  CLASSIFICATION_REVOKED
  ATTESTATION_RECEIVED # Deprecated - kept for backward compatibility
  LOT_RECEIVED
  LOT_TRANSFERRED
  # Vehicle activities
  CAPITAL_CONTRIBUTED
  DISTRIBUTION_CREATED
  DISTRIBUTION_CLAIMED
  MEMBER_ADDED
  MEMBER_REMOVED
}

type Offering @entity {
  id: ID! # Offering address
  issuer: Bytes!
  admin: Bytes! # Admin address for access control
  token: Token # Nullable, reference to any token type via interface
  paymentToken: Bytes!
  paymentRecipient: Bytes!
  pricePerToken: BigInt!
  minInvestment: BigInt!
  maxAmount: BigInt!
  deadline: BigInt!
  totalInvested: BigInt!
  investorCount: BigInt!
  status: OfferingStatus!
  deployer: Bytes! # Address that deployed the offering
  createdAt: BigInt!
  createdTx: Bytes!
  uri: String # Optional metadata URI
  complianceModules: [Bytes!]! # Compliance modules used
  
  # Compliance settings
  generalSolicitation: Boolean
  allowsSelfCertification: Boolean
  
  # Offchain investment tracking
  totalOffchainPending: BigInt # Nullable for backwards compatibility
  totalOffchainConfirmed: BigInt # Nullable for backwards compatibility
  
  # Relationships
  investments: [Investment!]! @derivedFrom(field: "offering")
  offchainInvestments: [OffchainInvestment!]! @derivedFrom(field: "offering")
  requiredTemplate: OfferingTemplate # The required template for this offering
  documents: [OfferingDocument!]! @derivedFrom(field: "offering") # Document instances created from the template
}

# Document template stored in offering contract
type OfferingTemplate @entity {
  id: ID! # templateId (bytes32 as hex string)
  offering: Offering! # The offering this template belongs to
  contentHash: Bytes!
  storageURI: String
  title: String!
  category: String
  creator: Bytes!
  createdAt: BigInt!
  createdTx: Bytes!
  eligibility: SignerEligibility # Set when this template is made required
  
  # Relationships
  documents: [OfferingDocument!]! @derivedFrom(field: "template") # Documents created from this template
  signatures: [OfferingDocumentSignature!]! @derivedFrom(field: "template") # All signatures on documents from this template
}

# Document instance created from a template (stored in offering contract)
type OfferingDocument @entity {
  id: ID! # documentId (bytes32 as hex string)
  offering: Offering!
  template: OfferingTemplate!
  title: String!
  creator: Bytes!
  createdAt: BigInt!
  createdTx: Bytes!
  
  # Relationships
  signatures: [OfferingDocumentSignature!]! @derivedFrom(field: "document")
}

# Signature on an offering document
type OfferingDocumentSignature @entity {
  id: ID! # tx-hash-logIndex
  offering: Offering!
  template: OfferingTemplate!
  document: OfferingDocument # Nullable to handle cases where signature is created before document
  signer: Bytes!
  signedAt: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
  logIndex: BigInt!
}

enum OfferingStatus {
  DRAFT
  ACTIVE
  COMPLETED
  CANCELLED
}

enum AcquisitionStatus {
  DRAFT
  LISTED
  UNDER_OFFER
  IN_ESCROW
  COMPLETED
  CANCELLED
  DISPUTED
}

enum SignerEligibility {
  COMPLIANT_ONLY
  WHITELISTED_ONLY
  CUSTOM_MODULE
  EXPLICIT_LIST
}

enum InvestmentStatus {
  PENDING
  ACCEPTED
  REJECTED
}

# Lookup table for finding investments by compositeId
type InvestmentLookup @entity {
  id: ID! # offering-investmentId (compositeId)
  investment: Investment! # Points to the actual investment entity
}

type Investment @entity {
  id: ID! # tx-hash-logIndex (unique event identifier)
  compositeId: String! # offering-investmentId (for protocol lookups)
  offering: Offering!
  investor: Wallet!
  investmentId: BigInt! # Protocol's internal investment ID
  amount: BigInt!
  tokenQuantity: BigInt!
  investedAt: BigInt!
  investedTx: Bytes!
  investedBlockNumber: BigInt!
  
  # Status management
  status: InvestmentStatus!
  
  # Countersign data (when status = ACCEPTED)
  countersignedAt: BigInt
  countersignedTx: Bytes
  
  # Rejection data (when status = REJECTED)
  rejectedAt: BigInt
  rejectedTx: Bytes
  
  # Attestations
  identityUID: Bytes!
  qualificationUID: Bytes!
}

type OffchainInvestment @entity {
  id: ID! # offering-investmentId (compositeId for protocol lookups)
  offering: Offering!
  investor: Wallet!
  investmentId: BigInt! # Protocol's internal investment ID
  amount: BigInt!
  tokenQuantity: BigInt!
  paymentMethod: String!
  referenceId: String!
  recordedAt: BigInt!
  recordedTx: Bytes!
  recordedBlockNumber: BigInt!
  recordedBy: Bytes! # Admin who recorded it
  
  # Status management
  status: OffchainInvestmentStatus!
  
  # Confirmation data (when status = CONFIRMED)
  confirmedAt: BigInt
  confirmedTx: Bytes
  confirmedBy: Bytes
  
  # Cancellation data (when status = CANCELLED)
  cancelledAt: BigInt
  cancelledTx: Bytes
  cancelledBy: Bytes
}

enum OffchainInvestmentStatus {
  PENDING
  CONFIRMED
  CANCELLED
}

# ============ ACQUISITION ENTITIES ============

type Acquisition @entity {
  id: ID! # Acquisition address
  address: Bytes!
  seller: Bytes!
  buyer: Bytes
  arbiter: Bytes
  price: BigInt!
  status: AcquisitionStatus!
  
  # Creation data
  createdAt: BigInt!
  createdAtBlock: BigInt!
  transactionHash: Bytes!
  
  # Lifecycle timestamps
  listedAt: BigInt
  listedAtBlock: BigInt
  cancelledAt: BigInt
  cancelledAtBlock: BigInt
  offerAcceptedAt: BigInt
  offerAcceptedAtBlock: BigInt
  disputeRaisedAt: BigInt
  disputeRaisedAtBlock: BigInt
  disputeRaisedBy: Bytes
}

# ============ TOKEN ENTITIES ============

# Interface for all token types (common fields)
interface Token {
  id: ID! # Token address
  name: String!
  symbol: String!
  decimals: Int!
  totalSupply: BigInt!
  admin: Bytes! # The issuer/owner of the token (company's smart account)
  createdAt: BigInt!
  createdTx: Bytes!
  assetType: TokenAssetType!
  complianceConditions: [Bytes!]! # Compliance conditions used
  
  # Admin state (from TokenAdminFacet)
  paused: Boolean!
  frozenAccounts: [Bytes!]!
  frozenLots: [Bytes!]!
  retired: Boolean! # Token has been retired (soft flag)
  retiredAt: BigInt # Timestamp when retired (null if not retired)
  
  # Transfer conditions (legacy - deprecated, use complianceModules instead)
  transferController: Bytes
  hasTransferConditions: Boolean!
  
  # Compliance Modules
  complianceModules: [TokenComplianceConfig!]!
  
  # Relationships
  lots: [Lot!]!
  offerings: [Offering!]!
}

# ShareClass tokens (equity shares)
type ShareClass implements Token @entity {
  id: ID!
  name: String!
  symbol: String!
  decimals: Int!
  totalSupply: BigInt!
  admin: Bytes!
  createdAt: BigInt!
  createdTx: Bytes!
  assetType: TokenAssetType!
  complianceConditions: [Bytes!]!
  paused: Boolean!
  frozenAccounts: [Bytes!]!
  frozenLots: [Bytes!]!
  retired: Boolean!
  retiredAt: BigInt
  transferController: Bytes
  hasTransferConditions: Boolean!
  complianceModules: [TokenComplianceConfig!]! @derivedFrom(field: "token")
  lots: [Lot!]! @derivedFrom(field: "token")
  offerings: [Offering!]! @derivedFrom(field: "token")
  
  # ShareClass-specific fields (from TokenAdminFacet)
  maxSupply: BigInt! # 0 = unlimited (from TokenAdminFacet)
  
  # Corporate actions (from TokenCorporateActionsFacet)
  splitNum: BigInt! # Cumulative split numerator
  splitDen: BigInt! # Cumulative split denominator
  divNum: BigInt! # Cumulative dividend numerator
  divDen: BigInt! # Cumulative dividend denominator
  totalSplits: Int! # Count of splits applied
  totalDividends: Int! # Count of dividends applied
  isPublic: Boolean! # Whether entity is SEC registered
  
  # Access control (from AccessControlFacet)
  roleMembers: [TokenRoleMember!]! @derivedFrom(field: "token")
  
  # Corporate action history
  corporateActions: [CorporateAction!]! @derivedFrom(field: "token")
}

# Token role membership tracking
type TokenRoleMember @entity {
  id: ID! # token-user-role (e.g., "0x123...abc-0x456...def-1")
  token: ShareClass!
  user: Bytes!
  role: Int! # uint8 role ID
  enabled: Boolean!
  grantedAt: BigInt!
  grantedTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

# Corporate action history tracking
type CorporateAction @entity {
  id: ID! # tx-logIndex (e.g., "0x123...abc-5")
  token: ShareClass!
  actionType: CorporateActionType!
  numerator: BigInt! # Split/dividend numerator
  denominator: BigInt! # Split/dividend denominator
  reducesBasis: Boolean # For dividends only, whether cost basis reduces
  timestamp: BigInt!
  tx: Bytes!
}

enum CorporateActionType {
  StockSplit
  StockDividend
}

# Email-gated token claims
type TokenClaim @entity {
  id: ID! # claimId (bytes32)
  token: ShareClass!
  emailHash: Bytes!
  quantity: BigInt!
  expiresAt: BigInt!
  redeemed: Boolean!
  issuer: Bytes!
  recipient: Bytes # null until redeemed
  lotId: Bytes # null until redeemed
  createdAt: BigInt!
  createdTx: Bytes!
  redeemedAt: BigInt # null until redeemed
  redeemedTx: Bytes # null until redeemed
}

# SAFE tokens (Simple Agreement for Future Equity)
# COMMENTED OUT - Will implement in Phase 4
# type Safe implements Token @entity {
#   id: ID!
#   name: String!
#   symbol: String!
#   decimals: Int!
#   totalSupply: BigInt!
#   admin: Bytes!
#   creator: Bytes!
#   deployer: Bytes!
#   createdAt: BigInt!
#   createdTx: Bytes!
#   assetType: TokenAssetType!
#   complianceConditions: [Bytes!]!
#   paused: Boolean!
#   frozenAccounts: [Bytes!]!
#   frozenLots: [Bytes!]!
#   transferController: Bytes
#   hasTransferConditions: Boolean!
#   lots: [Lot!]! @derivedFrom(field: "token")
#   offerings: [Offering!]! @derivedFrom(field: "token")
#   
#   # SAFE-specific fields (from TokenSAFEFacet)
#   issuer: Bytes!
#   defaultValuationCap: BigInt! # 0 = no cap
#   defaultDiscountRate: BigInt! # Basis points (e.g., 2000 = 20%)
#   defaultProRataRight: Boolean!
#   defaultTargetEquityToken: Bytes! # Which share class this converts to
#   defaultHasMFN: Boolean! # Most Favored Nation clause
#   
#   # Conversions
#   conversions: [SAFEConversion!]! @derivedFrom(field: "safe")
# }

# Employee Stock Options
# COMMENTED OUT - Will implement in Phase 4
# type EmployeeStockOption implements Token @entity {
#   id: ID!
#   name: String!
#   symbol: String!
#   decimals: Int!
#   totalSupply: BigInt! # Pool size
#   admin: Bytes!
#   creator: Bytes!
#   deployer: Bytes!
#   createdAt: BigInt!
#   createdTx: Bytes!
#   assetType: TokenAssetType!
#   complianceConditions: [Bytes!]!
#   paused: Boolean!
#   frozenAccounts: [Bytes!]!
#   frozenLots: [Bytes!]!
#   transferController: Bytes
#   hasTransferConditions: Boolean!
#   lots: [Lot!]! @derivedFrom(field: "token")
#   offerings: [Offering!]! @derivedFrom(field: "token")
#   
#   # ESO-specific fields (from TokenESOFacet)
#   issuer: Bytes!
#   underlyingShareClass: ShareClass # Which share class these options are for
#   defaultExercisePrice: BigInt!
#   defaultExpirationPeriod: BigInt! # Seconds after grant
#   poolSize: BigInt! # Total options allocated to pool
#   optionsGranted: BigInt! # Options already granted
#   optionsExercised: BigInt! # Options exercised
#   
#   # Grants
#   grants: [ESOGrant!]! @derivedFrom(field: "option")
# }

# Stock Appreciation Rights
# COMMENTED OUT - Will implement in Phase 4
# type StockAppreciationRight implements Token @entity {
#   id: ID!
#   name: String!
#   symbol: String!
#   decimals: Int!
#   totalSupply: BigInt! # Pool size
#   admin: Bytes!
#   deployer: Bytes!
#   createdAt: BigInt!
#   createdTx: Bytes!
#   assetType: TokenAssetType!
#   complianceConditions: [Bytes!]!
#   paused: Boolean!
#   frozenAccounts: [Bytes!]!
#   frozenLots: [Bytes!]!
#   transferController: Bytes
#   hasTransferConditions: Boolean!
#   lots: [Lot!]! @derivedFrom(field: "token")
#   offerings: [Offering!]! @derivedFrom(field: "token")
#   
#   # SAR-specific fields (from TokenSARFacet)
#   issuer: Bytes!
#   underlyingShareClass: ShareClass # Which share class these SARs reference
#   basePrice: BigInt! # Base price for appreciation calculation
#   settlementType: String! # "Cash" or "Shares"
#   poolSize: BigInt! # Total SARs allocated to pool
#   sarsGranted: BigInt! # SARs already granted
#   sarsExercised: BigInt! # SARs exercised
#   
#   # Grants
#   grants: [SARGrant!]! @derivedFrom(field: "sar")
# }

enum TokenAssetType {
  ShareClass
  UnitInterest # LLC/LP unit interests (for investment vehicles)
  Safe # Simple Agreement for Future Equity
  # Future token types (commented out until implemented):
  # EmployeeStockOption
  # Warrant
  # StockAppreciationRight
}

# SAFE Token Type
type Safe implements Token @entity {
  # Token interface fields
  id: ID! # Token address
  name: String!
  symbol: String!
  decimals: Int!
  totalSupply: BigInt!
  creator: Bytes! # Kept for backwards compatibility
  admin: Bytes!
  deployer: Bytes!
  createdAt: BigInt!
  createdTx: Bytes!
  assetType: TokenAssetType!
  
  # Compliance
  complianceConditions: [Bytes!]! # Compliance conditions used
  
  # Admin state
  paused: Boolean!
  frozenAccounts: [Bytes!]!
  frozenLots: [Bytes!]!
  retired: Boolean!
  retiredAt: BigInt
  transferController: Bytes
  hasTransferConditions: Boolean!
  complianceModules: [TokenComplianceConfig!]! @derivedFrom(field: "token")
  lots: [Lot!]! @derivedFrom(field: "token")
  offerings: [Offering!]! @derivedFrom(field: "token")
  
  # SAFE-specific fields
  defaultValuationCap: BigInt! # Default valuation cap (0 = uncapped)
  defaultDiscountRate: Int! # Default discount rate in basis points
  defaultTargetEquityToken: Bytes! # Default ShareClass to convert into
  defaultProRataRight: Boolean! # Default pro-rata participation rights
  defaultHasMFN: Boolean! # Default Most Favored Nation clause
  
  # Statistics
  totalInvested: BigInt!
  totalConverted: BigInt!
  lotsConverted: Int!
  
  # Conversions
  conversions: [SAFEConversion!]! @derivedFrom(field: "safe")
}

# SAFE Conversion tracking
type SAFEConversion @entity {
  id: ID! # tx-hash-logIndex
  safe: Safe!
  safeLot: Lot! # The SAFE lot being converted
  investor: Bytes!
  investmentAmount: BigInt!
  sharesIssued: BigInt!
  effectivePrice: BigInt!
  targetShareClass: Bytes! # ShareClass token address
  equityLotId: Bytes! # The new equity lot created
  conversionNote: String!
  convertedAt: BigInt!
  convertedTx: Bytes!
  blockNumber: BigInt!
  logIndex: BigInt!
}

# FUTURE: ESO Grant tracking (uncomment when implementing ESO tokens)
# type ESOGrant @entity {
#   id: ID! # option-grant-index
#   option: EmployeeStockOption!
#   grantee: Wallet!
#   lot: Lot! # The ESO lot for this grant
#   quantity: BigInt!
#   exercisePrice: BigInt!
#   grantedAt: BigInt!
#   cliffDate: BigInt!
#   expirationDate: BigInt!
#   vestedAmount: BigInt!
#   exercisedAmount: BigInt!
#   isRevoked: Boolean!
#   revokedAt: BigInt
# }

# FUTURE: SAR Grant tracking (uncomment when implementing SAR tokens)
# type SARGrant @entity {
#   id: ID! # sar-grant-index
#   sar: StockAppreciationRight!
#   grantee: Wallet!
#   lot: Lot! # The SAR lot for this grant
#   quantity: BigInt!
#   basePrice: BigInt!
#   grantedAt: BigInt!
#   cliffDate: BigInt!
#   expirationDate: BigInt!
#   vestedAmount: BigInt!
#   exercisedAmount: BigInt!
#   isRevoked: Boolean!
#   revokedAt: BigInt
# }

# Transfer Conditions (vesting, lockups, etc.)
type TransferCondition @entity {
  id: ID! # token-condition-index
  token: Token! # Can apply to any token type
  conditionType: TransferConditionType!
  account: Bytes!
  lot: Lot # Optional: specific to a lot
  
  # Vesting-specific fields
  startDate: BigInt
  cliffDate: BigInt
  endDate: BigInt
  totalAmount: BigInt
  claimedAmount: BigInt!
  
  # State
  revoked: Boolean!
  revokedAt: BigInt
  
  createdAt: BigInt!
  createdTx: Bytes!
}

enum TransferConditionType {
  Vesting
  Lockup
  Custom
}

# ============ COMPLIANCE MODULES ============

# Compliance module registry - tracks all compliance modules used across tokens
type ComplianceModule @entity {
  id: ID! # module-address
  address: Bytes!
  name: String!
  version: String!
  moduleType: String! # "HoldingPeriod", "VolumeLimit", "AffiliateStatus", "Vesting", "Lockup", "Custom"
  firstUsedAt: BigInt!
  firstUsedTx: Bytes!
  
  # Relationships
  tokens: [TokenComplianceConfig!]! @derivedFrom(field: "module")
}

# Token-level compliance configuration - which modules are active for each token
type TokenComplianceConfig @entity {
  id: ID! # token-module
  token: Token!
  module: ComplianceModule!
  isGlobal: Boolean! # True if applies to all lots, false if lot-specific
  addedAt: BigInt!
  addedTx: Bytes!
  removedAt: BigInt
  removedTx: Bytes
  isActive: Boolean! # False if removed
}

# Lot-specific module assignment (overrides or additions to global modules)
type LotComplianceConfig @entity {
  id: ID! # lot-module
  lot: Lot!
  module: ComplianceModule!
  addedAt: BigInt!
  addedTx: Bytes!
}

# ============ MODULE-SPECIFIC ENTITIES ============

# Holding Period Module - tracks acquisition dates and required holding periods
type HoldingPeriodConfig @entity {
  id: ID! # token-lotId-holder
  token: Token!
  lotId: Bytes! # bytes32 lot identifier
  holder: Bytes!
  module: ComplianceModule! # Reference to the HoldingPeriodModule instance
  holdingPeriod: BigInt! # Required holding period in seconds (from token-level config)
  acquisitionDate: BigInt! # When holder acquired this lot
  unlockDate: BigInt! # Calculated: acquisitionDate + holdingPeriod
  isUnlocked: Boolean! # True if current time >= unlockDate
  
  # Tracking
  createdAt: BigInt!
  createdTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

# Volume Limit Module - tracks rolling volume limits for affiliates
type VolumeLimitConfig @entity {
  id: ID! # token-holder
  token: Token!
  holder: Bytes!
  module: ComplianceModule! # Reference to the VolumeLimitModule instance
  
  # Configuration (from token-level settings)
  limitBps: Int! # Basis points (100 = 1%, 10000 = 100%)
  windowSeconds: BigInt! # Time window for volume tracking
  
  # Current window state
  currentWindowStart: BigInt! # When current window started
  currentVolume: BigInt! # Cumulative volume in current window
  lastTransferAt: BigInt # Last time volume was recorded
  
  # Tracking
  createdAt: BigInt!
  createdTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

# Affiliate Status Module - tracks which holders are affiliates
type AffiliateStatus @entity {
  id: ID! # token-holder
  token: Token!
  holder: Bytes!
  module: ComplianceModule! # Reference to the AffiliateStatusModule instance
  isAffiliate: Boolean!
  affiliateSince: BigInt # When holder became affiliate (null if never was)
  affiliateUntil: BigInt # When holder stopped being affiliate (null if currently is)
  
  # History tracking
  statusChanges: [AffiliateStatusChange!]! @derivedFrom(field: "affiliateStatus")
  
  # Tracking
  createdAt: BigInt!
  createdTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

# History of affiliate status changes
type AffiliateStatusChange @entity {
  id: ID! # tx-hash-logIndex
  affiliateStatus: AffiliateStatus!
  becameAffiliate: Boolean! # True if became affiliate, false if revoked
  changedAt: BigInt!
  changedTx: Bytes!
}

# Lockup Compliance Module - tracks time-based lockups per lot
type LockupConfig @entity {
  id: ID! # lotId (bytes32 as hex string)
  lotId: Bytes! # bytes32 lot identifier
  unlockTime: BigInt! # Unix timestamp when lot becomes transferable
  
  # Tracking
  createdAt: BigInt!
  createdTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

# Vesting Compliance Module - tracks vesting schedules per lot
type VestingConfig @entity {
  id: ID! # lotId (bytes32 as hex string)
  lotId: Bytes! # bytes32 lot identifier
  holder: Bytes! # Token holder address
  totalBasisPoints: BigInt! # Percentage of lot to vest (10000 = 100%)
  releasedBasisPoints: BigInt! # Percentage already released
  startTime: BigInt! # Vesting start timestamp
  duration: BigInt! # Total vesting duration in seconds
  cliffDuration: BigInt! # Cliff period in seconds
  revocable: Boolean! # Whether the schedule can be revoked
  revoked: Boolean! # Whether the schedule has been revoked
  
  # Tracking
  createdAt: BigInt!
  createdTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

type Lot @entity {
  id: ID! # token-lotId
  token: Token! # Can reference any token type via interface
  lotId: BigInt!
  owner: Wallet!
  quantity: BigInt! # Raw quantity (before corporate actions). To get real quantity: quantity * token.splitNum * token.divNum / (token.splitDen * token.divDen)
  costBasis: BigInt! # Raw cost basis (before adjustments)
  acquisitionDate: BigInt!
  createdAt: BigInt! # Alias for acquisitionDate
  acquiredFrom: Bytes!
  parentLotId: BigInt # For lot splits/transfers
  assetId: String # Token identifier
  paymentCurrency: Bytes # Currency used for acquisition
  paymentDecimals: Int # Decimals of the payment currency
  customId: BigInt # Custom ID for user-friendly lot identification
  uri: String # URI of the lot
  isValid: Boolean! # Whether the lot is active (false if burned/invalidated)
  data: Bytes # Additional data associated with the lot
  transferType: String # Transfer type (INTERNAL, SALE, GIFT, INHERITANCE, INCOME)
  metadata: String
  
  # Adjustment history
  adjustedFrom: Lot # Reference to parent lot if this was created via adjustment
  adjustments: [LotAdjustment!]! @derivedFrom(field: "lot")
  
  # State
  frozen: Boolean!
  frozenAt: BigInt
  
  # Compliance
  lotSpecificModules: [LotComplianceConfig!]! @derivedFrom(field: "lot") # Lot-specific compliance modules (in addition to token's global modules)
  
  # Type-specific references (optional - uncomment as needed)
  # esoGrant: ESOGrant # If this is an ESO grant lot
  # sarGrant: SARGrant # If this is a SAR grant lot
  # safeConversion: SAFEConversion # If this lot was created from SAFE conversion
}

type LotAdjustment @entity {
  id: ID! # tx-hash-logIndex
  oldLot: Lot!
  newLot: Lot!
  operator: Bytes!
  owner: Bytes!
  newQuantity: BigInt!
  newCostBasis: BigInt!
  paymentCurrency: Bytes!
  acquisitionDate: BigInt!
  uri: String!
  data: Bytes!
  reason: String!
  transferType: String!
  adjustedCostBasis: BigInt! # The delta in cost basis
  timestamp: BigInt!
  transaction: Bytes!
  lot: Lot! # For reverse lookup
}

type CustomIdUpdate @entity {
  id: ID! # tx-hash-logIndex
  lot: Lot!
  oldCustomId: BigInt!
  newCustomId: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

# ============ PRE-APPROVED TERMS (Offering-specific) ============

# Interface for all pre-approved term types
interface PreApprovedTerms {
  id: ID! # offering-investor
  offering: Offering!
  investor: Bytes!
  encodedTerms: Bytes! # Raw encoded data
  assetType: TokenAssetType!
  setAt: BigInt!
  setTx: Bytes!
  setBy: Bytes! # Admin who set the terms
  cleared: Boolean!
  clearedAt: BigInt
  clearedTx: Bytes
  clearedBy: Bytes
}

# SAFE-specific pre-approved terms
type SafePreApprovedTerms implements PreApprovedTerms @entity {
  id: ID! # offering-investor
  offering: Offering!
  investor: Bytes!
  encodedTerms: Bytes!
  assetType: TokenAssetType!
  setAt: BigInt!
  setTx: Bytes!
  setBy: Bytes!
  cleared: Boolean!
  clearedAt: BigInt
  clearedTx: Bytes
  clearedBy: Bytes
  
  # SAFE-specific decoded fields
  valuationCap: BigInt! # 0 = uncapped
  discountRate: Int! # Basis points (e.g., 2000 = 20%)
  interestRate: Int! # Basis points (e.g., 500 = 5%)
  maturityDate: BigInt! # Unix timestamp, 0 = no maturity
}

# ============ COMPLIANCE (ComplianceStorage-based) ============

type KYCStatus @entity {
  id: ID! # offering-address-wallet-address (e.g., "0x123...abc-0x456...def")
  offering: Offering!
  wallet: Wallet!
  verified: Boolean!
  expirationTime: BigInt!
  verifiedBy: Bytes!
  updatedAt: BigInt!
  updatedTx: Bytes!
  revoked: Boolean!
  revokedAt: BigInt
  revokedTx: Bytes
  revokedBy: Bytes
}

type InvestorClassification @entity {
  id: ID! # offering-address-wallet-address-classification (e.g., "0x123...abc-0x456...def-ACCREDITED_INVESTOR")
  offering: Offering!
  wallet: Wallet!
  classification: String! # Classification string (e.g., "ACCREDITED_INVESTOR", "NON_ACCREDITED_INVESTOR")
  classificationHash: Bytes! # bytes32 hash for compatibility
  addedAt: BigInt!
  addedTx: Bytes!
  addedBy: Bytes!
  revoked: Boolean!
  revokedAt: BigInt
  revokedTx: Bytes
  revokedBy: Bytes
}

# Deprecated: Old EAS-based attestations (kept for backward compatibility)
type Attestation @entity {
  id: ID! # attestation UID
  schema: Bytes! # Schema UID
  attester: Bytes!
  wallet: Wallet! # The wallet this attestation is about
  data: Bytes!
  createdAt: BigInt!
  expiresAt: BigInt
  revoked: Boolean!
  revokedAt: BigInt
  
  # Decoded fields for unified investor schema: (address offering, bool isVerified, bytes32[] classifications)
  offering: Bytes # Offering address (0x0 = universal/global attestation)
  isVerified: Boolean # KYC/identity verification status
  classifications: [Bytes!]! # Investor classifications (e.g., ACCREDITED, NON_ACCREDITED, SOPHISTICATED)
}

# ============ FACET REGISTRY ============

type Facet @entity {
  id: ID! # Facet address
  name: String!
  version: BigInt!
  selectors: [String!]!
  createdAt: BigInt!
  createdTx: Bytes!
  deploymentSalt: Bytes # Salt used for CREATE2 deployment (if deployed via registry)
  removed: Boolean!
  removedAt: BigInt
  removedTx: Bytes
}

type FacetRegistryEvent @entity {
  id: ID! # tx-logIndex
  eventType: FacetRegistryEventType!
  facet: Bytes!
  facetName: String!
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
  
  # For FacetDeployed events
  deploymentSalt: Bytes
  selectors: [String!]
}

enum FacetRegistryEventType {
  REGISTERED
  REMOVED
  DEPLOYED
}

# ============ PAYMENT TOKENS ============

# Generic ERC20 token entity (reusable across offerings, factories, etc.)
type PaymentToken @entity {
  id: ID! # Token address
  address: Bytes!
  symbol: String!
  decimals: Int!
  name: String!
  
  # Where this token is used
  factoryConfigs: [FactoryPaymentTokenConfig!]! @derivedFrom(field: "paymentToken")
  
  createdAt: BigInt!
  createdTx: Bytes!
}

# ============ FACTORY PAYMENT TRACKING ============

type FactoryPaymentConfig @entity {
  id: ID! # factory-address
  factory: Bytes!
  factoryType: FactoryType! # TOKEN, OFFERING, WALLET
  feeRecipient: Bytes!
  paymentsEnabled: Boolean!
  deploymentCount: BigInt!
  
  # Payment token configurations
  paymentTokens: [FactoryPaymentTokenConfig!]! @derivedFrom(field: "factoryConfig")
  
  # Payments collected
  payments: [FactoryPayment!]! @derivedFrom(field: "factory")
  
  createdAt: BigInt!
  createdTx: Bytes!
}

# Factory-specific configuration for a payment token
type FactoryPaymentTokenConfig @entity {
  id: ID! # factory-token
  factoryConfig: FactoryPaymentConfig!
  paymentToken: PaymentToken! # Reference to the token entity
  feeAmount: BigInt!
  isActive: Boolean!
  totalCollected: BigInt!
  
  configuredAt: BigInt!
  configuredTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

type FactoryPayment @entity {
  id: ID! # tx-logIndex
  factory: FactoryPaymentConfig!
  payer: Bytes!
  paymentToken: Bytes!
  amount: BigInt!
  deploymentType: String! # "Token", "Offering", "Wallet"
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

enum FactoryType {
  TOKEN
  OFFERING
  WALLET
}
