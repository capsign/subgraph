type Diamond @entity {
  id: ID! # Diamond address
  diamondType: String! # WALLET, OFFERING, TOKEN
  creator: Bytes!
  createdAt: BigInt!
  createdTx: Bytes!
  
  # Polymorphic relationships (optional - diamonds may be tracked separately)
  wallet: Wallet
  offering: Offering
  token: Token
}

type Wallet @entity {
  id: ID! # Wallet address
  type: String! # "EOA", "Passkey", "MPC"
  deployer: Bytes! # Address that deployed the wallet
  createdAt: BigInt!
  createdTx: Bytes!
  
  # Owners (multiple allowed)
  owners: [Owner!]! @derivedFrom(field: "wallet")
  
  # Documents
  documents: [Document!]! @derivedFrom(field: "wallet")
  
  # Relationships
  tokens: [Lot!]! @derivedFrom(field: "owner")
  investments: [Investment!]! @derivedFrom(field: "investor")
  attestations: [Attestation!]! @derivedFrom(field: "wallet")
}

type Owner @entity {
  id: ID! # wallet-address or wallet-publicKeyHash
  wallet: Wallet!
  ownerType: OwnerType!
  address: Bytes # For EOA and MPC owners
  publicKey: Bytes # For Passkey owners (64 bytes: x + y coordinates)
  publicKeyHash: Bytes # For Passkey owners (hash for indexing)
  addedAt: BigInt!
  addedTx: Bytes!
}

enum OwnerType {
  EOA
  Passkey
  MPC
}

type Document @entity {
  id: ID! # documentId (bytes32)
  wallet: Wallet!
  contentHash: Bytes!
  storageURI: String!
  category: String!
  title: String!
  creator: Bytes!
  createdAt: BigInt!
  requiredSigners: [Bytes!]!
  
  # Signatures
  signatures: [DocumentSignature!]! @derivedFrom(field: "document")
}

type DocumentSignature @entity {
  id: ID! # documentId-signer
  document: Document!
  signer: Bytes!
  signedAt: BigInt!
}

type Offering @entity {
  id: ID! # Offering address
  issuer: Bytes!
  admin: Bytes! # Admin address for access control
  token: Token # Nullable in case token isn't indexed yet
  paymentToken: Bytes!
  paymentRecipient: Bytes!
  pricePerToken: BigInt!
  minInvestment: BigInt!
  maxAmount: BigInt!
  deadline: BigInt!
  totalInvested: BigInt!
  investorCount: BigInt!
  status: OfferingStatus!
  deployer: Bytes! # Address that deployed the offering
  createdAt: BigInt!
  createdTx: Bytes!
  uri: String # Optional metadata URI
  complianceModules: [Bytes!]! # Compliance modules used
  
  # Parsed metadata (fetched from URI)
  name: String
  description: String
  image: String
  offeringType: OfferingType # 506b, 506c, reg_a, reg_cf, custom
  issuerName: String
  issuerJurisdiction: String
  issuerWebsite: String
  issuerLogo: String
  generalSolicitation: Boolean
  investorLimit: BigInt # 0 = unlimited
  metadataFetched: Boolean! # True if metadata was successfully fetched
  
  # Relationships
  investments: [Investment!]! @derivedFrom(field: "offering")
}

enum OfferingStatus {
  ACTIVE
  PAUSED
  CLOSED
  FINALIZED
}

enum OfferingType {
  TYPE_506B
  TYPE_506C
  REG_A
  REG_CF
  CUSTOM
  UNKNOWN
}

type Investment @entity {
  id: ID! # offering-investmentId
  offering: Offering!
  investor: Wallet!
  investmentId: BigInt!
  amount: BigInt!
  tokenQuantity: BigInt!
  investedAt: BigInt!
  isCountersigned: Boolean!
  countersignedAt: BigInt
  isRejected: Boolean!
  rejectedAt: BigInt
  identityUID: Bytes!
  qualificationUID: Bytes!
}

type Token @entity {
  id: ID! # Token address
  name: String!
  symbol: String!
  decimals: Int!
  totalSupply: BigInt!
  admin: Bytes! # Admin address for access control
  creator: Bytes! # Original creator (kept for backwards compatibility)
  deployer: Bytes! # Address that deployed the token
  createdAt: BigInt!
  createdTx: Bytes!
  assetType: TokenAssetType!
  complianceConditions: [Bytes!]! # Compliance conditions used
  
  # Relationships
  lots: [Lot!]! @derivedFrom(field: "token")
  offerings: [Offering!]! @derivedFrom(field: "token")
}

enum TokenAssetType {
  SHARE
  UNIT_INTEREST
  SAFE
  EMPLOYEE_STOCK_OPTION
  WARRANT
  SAR
}

type Lot @entity {
  id: ID! # token-lotId
  token: Token!
  lotId: BigInt!
  owner: Wallet!
  balance: BigInt!
  quantity: BigInt! # Alias for balance
  acquisitionDate: BigInt!
  createdAt: BigInt! # Alias for acquisitionDate
  costBasis: BigInt!
  acquiredFrom: Bytes!
  parentLotId: BigInt # For lot splits/transfers
  assetId: String # Token identifier
  paymentCurrency: Bytes # Currency used for acquisition
  metadata: String
}

type Attestation @entity {
  id: ID! # attestation UID
  schema: Bytes! # Schema UID
  attester: Bytes!
  wallet: Wallet! # The wallet this attestation is about
  data: Bytes!
  createdAt: BigInt!
  expiresAt: BigInt
  revoked: Boolean!
  revokedAt: BigInt
  
  # Decoded fields for unified investor schema: (address offering, bool isVerified, bytes32[] classifications)
  offering: Bytes # Offering address (0x0 = universal/global attestation)
  isVerified: Boolean # KYC/identity verification status
  classifications: [Bytes!]! # Investor classifications (e.g., ACCREDITED, NON_ACCREDITED, SOPHISTICATED)
}

# ============ FACET REGISTRY ============

type Facet @entity {
  id: ID! # Facet address
  name: String!
  selectors: [String!]!
  createdAt: BigInt!
  createdTx: Bytes!
  deploymentSalt: Bytes # Salt used for CREATE2 deployment (if deployed via registry)
  removed: Boolean!
  removedAt: BigInt
  removedTx: Bytes
}

type FacetRegistryEvent @entity {
  id: ID! # tx-logIndex
  eventType: FacetRegistryEventType!
  facet: Bytes!
  facetName: String!
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
  
  # For FacetDeployed events
  deploymentSalt: Bytes
  selectors: [String!]
}

enum FacetRegistryEventType {
  REGISTERED
  REMOVED
  DEPLOYED
}
