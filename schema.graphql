type Diamond @entity {
  id: ID! # Diamond address
  diamondType: String! # WALLET, OFFERING, TOKEN
  creator: Bytes! # User/deployer who initiated the creation
  createdAt: BigInt!
  createdTx: Bytes!
  
  # Factory settings (for factory diamonds)
  facetRegistry: Bytes # Address of FacetRegistry (only for factory diamonds)
  
  # Polymorphic relationships (optional - diamonds may be tracked separately)
  wallet: Wallet
  offering: Offering
  token: Token # Can reference any token type via interface
  
  # Access control
  userRoles: [UserRole!]! @derivedFrom(field: "diamond")
  functionAccess: [FunctionAccess!]! @derivedFrom(field: "diamond")
  
  # Installed facets (diamond configuration)
  installedFacets: [InstalledFacet!]! @derivedFrom(field: "diamond")
  cutHistory: [DiamondCutEvent!]! @derivedFrom(field: "diamond")
}

# System configuration - single entity with id "system"
type SystemConfig @entity {
  id: ID! # Always "system"
  diamondFactory: Bytes! # Address of DiamondFactory
  facetRegistry: Bytes! # Address of FacetRegistry
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}


# Generic access control tracking for all diamonds
type UserRole @entity {
  id: ID! # diamond-user-role (e.g., "0x123...abc-0x456...def-1")
  diamond: Diamond!
  user: Bytes!
  role: Int! # uint8 role ID
  enabled: Boolean!
  grantedAt: BigInt!
  grantedTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

type UserRoleHistory @entity {
  id: ID! # tx-logIndex (unique per event)
  diamond: Diamond!
  user: Bytes!
  role: Int! # uint8 role ID
  enabled: Boolean! # true = granted, false = revoked
  changedBy: Bytes! # Transaction sender (admin who made the change)
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

type FunctionAccess @entity {
  id: ID! # diamond-functionSelector-role (e.g., "0x123...abc-0x12345678-1")
  diamond: Diamond!
  functionSelector: Bytes! # bytes4 function selector
  role: Int! # uint8 role ID
  hasAccess: Boolean! # true if role has access, false if revoked
  grantedAt: BigInt!
  grantedTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

type Wallet @entity {
  id: ID! # Wallet address (all CapSign wallets are ERC-4337 smart accounts)
  deployer: Bytes! # Address that deployed the wallet
  createdAt: BigInt!
  createdTx: Bytes!
  
  # Owners (full control - governance layer)
  owners: [Owner!]! @derivedFrom(field: "wallet")
  
  # Authorized Signers (role-limited - operational layer)
  signers: [AuthorizedSigner!]! @derivedFrom(field: "wallet")
  
  # UserOperation Executions (audit trail)
  executions: [UserOperationExecution!]! @derivedFrom(field: "wallet")
  
  # Documents
  documents: [Document!]! @derivedFrom(field: "wallet")
  
  # Relationships
  tokens: [Lot!]! @derivedFrom(field: "owner")
  investments: [Investment!]! @derivedFrom(field: "investor")
  kycStatus: KYCStatus
  classifications: [InvestorClassification!]! @derivedFrom(field: "wallet")
  
  # Access Manager - contracts this wallet manages
  managedContracts: [AuthorityDelegation!]! @derivedFrom(field: "authorityWallet")
  targetPermissions: [TargetFunctionPermission!]! @derivedFrom(field: "managerWallet")
  
  # Vehicle/Trust profiles (if wallet has these facets)
  vehicle: Vehicle
  trust: Trust
}

# Tracks which wallet (AccessManager) has authority over a contract (AccessManaged)
type AuthorityDelegation @entity {
  id: ID! # managedContract-authorityWallet (e.g., "0xtoken-0xwallet")
  managedContract: Bytes! # The token/offering diamond being managed
  authorityWallet: Wallet! # The wallet diamond acting as AccessManager
  setAt: BigInt!
  setTx: Bytes!
  previousAuthority: Bytes # Previous authority address (or null if first time)
}

# Tracks permissions configured by a wallet for calling functions on managed contracts
type TargetFunctionPermission @entity {
  id: ID! # managerWallet-target-selector (e.g., "0xwallet-0xtoken-0x12345678")
  managerWallet: Wallet! # The wallet that manages this permission
  targetContract: Bytes! # The contract (token/offering) this permission applies to
  functionSelector: Bytes! # bytes4 function selector
  requiredRole: Int! # uint8 role ID required on the manager wallet
  setAt: BigInt!
  setTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

type Owner @entity {
  id: ID! # wallet-address or wallet-publicKeyHash
  wallet: Wallet!
  ownerType: OwnerType!
  address: Bytes # For EOA and MPC owners
  publicKey: Bytes # For Passkey owners (64 bytes: x + y coordinates)
  publicKeyHash: Bytes # For Passkey owners (hash for indexing)
  addedAt: BigInt!
  addedTx: Bytes!
}

enum OwnerType {
  EOA
  Passkey
  MPC
}

# ============ AUTHORIZED SIGNERS ============
# Role-limited signers separate from full wallet owners
# Enables separation of governance (owners) from operations (signers)

type AuthorizedSigner @entity {
  id: ID! # wallet-signerId
  wallet: Wallet!
  signerId: Bytes! # bytes32 keccak256 of credentials
  signerType: SignerType!
  address: Bytes # For EOA signers
  publicKeyX: BigInt # For Passkey signers
  publicKeyY: BigInt # For Passkey signers
  roleId: Int! # Role limiting signer's access
  validUntil: BigInt # Expiry timestamp (0 = no expiry)
  isActive: Boolean!
  label: String
  addedAt: BigInt!
  addedTx: Bytes!
  removedAt: BigInt
  removedTx: Bytes
  
  # Executions by this signer
  executions: [UserOperationExecution!]! @derivedFrom(field: "signer")
}

enum SignerType {
  EOA
  Passkey
}

# Tracks each UserOperation execution for audit trail
type UserOperationExecution @entity {
  id: ID! # tx-hash-logIndex
  wallet: Wallet!
  userOpHash: Bytes!
  signer: AuthorizedSigner # null if owner executed
  signerId: Bytes! # bytes32(0) for owners, signerId for signers
  signerRole: Int! # 0 = admin/owner
  target: Bytes!
  functionSelector: Bytes!
  success: Boolean!
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
  logIndex: BigInt!
}

type Document @entity {
  id: ID! # Raw documentId (bytes32 as hex string)
  wallet: Wallet!
  contentHash: Bytes!
  storageURI: String!
  category: String!
  title: String!
  creator: Bytes!
  createdAt: BigInt!
  createdTx: Bytes!
  requiredSigners: [Bytes!]!
  
  # Parent-child relationship for template-based documents
  parentDocument: Document # Reference to template document (null if this is a template)
  childDocuments: [Document!]! @derivedFrom(field: "parentDocument") # Documents created from this template
  
  # Signatures
  signatures: [DocumentSignature!]! @derivedFrom(field: "document")
}

type DocumentSignature @entity {
  id: ID! # tx-hash-logIndex
  document: Document # Nullable to handle cases where DocumentSigned event is indexed before DocumentCreated
  signer: Bytes! # The primary signer (entity for representative signatures, individual otherwise)
  signedAt: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
  logIndex: BigInt!
  
  # Representative signing fields
  actualSigner: Bytes # The individual who physically signed (for representative signatures)
  onBehalfOf: Bytes # The entity on whose behalf it was signed
  isDelegated: Boolean! # True if actualSigner signed on behalf of onBehalfOf
}

# ============ PAYMASTER ENTITIES ============

type PaymasterPolicy @entity {
  id: ID! # Wallet address
  wallet: Wallet!
  enabled: Boolean!
  dailyBudget: BigInt!
  paymasterAddress: Bytes!
  
  # Policy configuration history
  configurations: [PaymasterPolicyConfiguration!]! @derivedFrom(field: "policy")
  
  # Role policies
  rolePolicies: [RolePolicy!]! @derivedFrom(field: "policy")
  
  # Spending tracking
  sponsoredTransactions: [SponsoredTransaction!]! @derivedFrom(field: "entityPolicy")
  totalSponsored: BigInt!
  
  updatedAt: BigInt!
  updatedTx: Bytes!
}

type PaymasterPolicyConfiguration @entity {
  id: ID! # tx-hash-logIndex
  policy: PaymasterPolicy!
  enabled: Boolean!
  dailyBudget: BigInt!
  paymasterAddress: Bytes!
  timestamp: BigInt!
  tx: Bytes!
}

type RolePolicy @entity {
  id: ID! # wallet-address-role
  policy: PaymasterPolicy!
  role: Int!
  canBeSponsored: Boolean!
  dailyLimit: BigInt!
  allowedOperations: [Bytes!]!
  updatedAt: BigInt!
  updatedTx: Bytes!
}

type SponsoredTransaction @entity {
  id: ID! # tx-hash-logIndex
  entityPolicy: PaymasterPolicy!
  entity: Bytes! # Entity wallet address
  user: Bytes! # User who was sponsored
  actualCost: BigInt! # Gas cost in wei
  refunded: BigInt! # Amount refunded to paymaster
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

type PaymasterDeposit @entity {
  id: ID! # tx-hash-logIndex
  entity: Bytes!
  amount: BigInt!
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

type PaymasterWithdrawal @entity {
  id: ID! # tx-hash-logIndex
  entity: Bytes!
  recipient: Bytes!
  amount: BigInt!
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

type PolicyCheckFailure @entity {
  id: ID! # tx-hash-logIndex
  entity: Bytes!
  user: Bytes!
  reason: String!
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

# ============ VEHICLE (SPV/Fund) ENTITIES ============

type Vehicle @entity {
  id: ID! # Vehicle wallet address
  wallet: Wallet! # The wallet that has vehicle facets
  vehicleType: VehicleType! # SPV, FUND, DAO
  
  # Capital accounting totals
  totalCapitalContributed: BigInt!
  totalDistributionsExecuted: BigInt!
  totalDistributionsClaimed: BigInt!
  
  # Token reference (for unit interest tokens)
  token: Token # The UNIT_INTEREST token representing ownership
  
  # Member tracking
  memberCount: Int!
  members: [VehicleMember!]! @derivedFrom(field: "vehicle")
  
  # Capital contributions
  contributions: [CapitalContribution!]! @derivedFrom(field: "vehicle")
  
  # Distributions
  distributions: [Distribution!]! @derivedFrom(field: "vehicle")
  
  # Investments (if SPV)
  investments: [VehicleInvestment!]! @derivedFrom(field: "vehicle")
  
  createdAt: BigInt!
  createdTx: Bytes!
}

enum VehicleType {
  SPV        # Special Purpose Vehicle (single investment)
  FUND       # Multi-investment fund
  DAO        # DAO LLC
}

type VehicleMember @entity {
  id: ID! # vehicle-member-address
  vehicle: Vehicle!
  memberAddress: Bytes!
  
  # Capital accounting for this member
  capitalContributed: BigInt!
  distributionsReceived: BigInt!
  
  # Token ownership (derived from lots)
  tokenBalance: BigInt! # Current token balance
  
  addedAt: BigInt!
  addedTx: Bytes!
  
  # Track if member has been removed
  removed: Boolean!
  removedAt: BigInt
  removedTx: Bytes
  
  # Contributions by this member
  contributions: [CapitalContribution!]! @derivedFrom(field: "member")
}

type CapitalContribution @entity {
  id: ID! # tx-hash-logIndex
  vehicle: Vehicle!
  member: VehicleMember!
  memberAddress: Bytes! # Denormalized for filtering
  amount: BigInt!
  
  # Context: where did this capital come from?
  source: CapitalSource! # OFFERING, DIRECT, TRANSFER
  offering: Offering # If source = OFFERING, reference the offering
  
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
  logIndex: BigInt!
}

enum CapitalSource {
  OFFERING   # From countersigned investment in an offering
  DIRECT     # Manually recorded contribution
  TRANSFER   # From token transfer (secondary market)
}

type Distribution @entity {
  id: ID! # vehicle-distributionId or trust-distributionId
  vehicle: Vehicle # Vehicle this distribution belongs to (null for trust distributions)
  trust: Trust # Trust this distribution belongs to (null for vehicle distributions)
  distributionId: BigInt! # Protocol's internal distribution ID
  totalAmount: BigInt!
  totalClaimed: BigInt! # Amount claimed so far
  lpAmount: BigInt! # Amount for limited partners (vehicle only)
  carryAmount: BigInt! # Amount for carry recipients (vehicle only)
  
  # Token references (claim-based model)
  paymentToken: Bytes! # Token being distributed (e.g., USDC)
  membershipToken: Bytes # Token determining eligibility (vehicle) or beneficialInterestToken (trust)
  
  # Distribution type (for trusts)
  distributionType: DistributionTypeEnum # INCOME, PRINCIPAL, LIQUIDATING
  
  # State
  cancelled: Boolean!
  cancelledAt: BigInt
  cancelledTx: Bytes
  expiresAt: BigInt # Expiration timestamp (0 = no expiry)
  
  createdAt: BigInt!
  createdTx: Bytes!
  blockNumber: BigInt!
  
  # Individual claims by members/beneficiaries
  claims: [DistributionClaim!]! @derivedFrom(field: "distribution")
}

enum DistributionTypeEnum {
  INCOME       # Regular income (rental, dividends)
  PRINCIPAL    # Return of capital
  LIQUIDATING  # Trust termination
}

type DistributionClaim @entity {
  id: ID! # distribution-claimant-address
  distribution: Distribution!
  claimantAddress: Bytes! # Address of the claimant (member or beneficiary)
  amount: BigInt!
  
  # For vehicle distributions
  vehicleMember: VehicleMember # Link to vehicle member (if vehicle distribution)
  isCarryRecipient: Boolean # True if this is a carry (GP) claim
  
  # For trust distributions
  trustParticipant: TrustParticipant # Link to trust participant (if trust distribution)
  
  # State
  claimed: Boolean!
  claimedAt: BigInt
  claimedTx: Bytes
  blockNumber: BigInt
  logIndex: BigInt
}

type VehicleInvestment @entity {
  id: ID! # vehicle-investmentId
  vehicle: Vehicle!
  investmentId: BigInt! # Protocol's internal investment ID
  assetType: VehicleAssetType!
  
  # Investment details
  target: Bytes! # Address of the investment target (company, protocol, etc.)
  amount: BigInt!
  entryDate: BigInt!
  entryTx: Bytes!
  
  # Exit details (if exited)
  exited: Boolean!
  exitAmount: BigInt
  exitDate: BigInt
  exitTx: Bytes
  
  # Current valuation (updated by vehicle admin)
  currentValuation: BigInt!
  lastValuationUpdate: BigInt!
}

enum VehicleAssetType {
  EQUITY        # Equity investment in a company
  DEBT          # Debt instrument
  CRYPTO        # Cryptocurrency holding
  DEFI          # DeFi protocol position
  REAL_ESTATE   # Real estate holding
  OTHER         # Other asset types
}

# Track NAV updates for the vehicle
type VehicleValuation @entity {
  id: ID! # tx-hash-logIndex
  vehicle: Vehicle!
  totalNAV: BigInt! # Net Asset Value
  navPerToken: BigInt! # NAV divided by total token supply
  
  # Breakdown
  totalAssets: BigInt!
  totalLiabilities: BigInt!
  
  updatedBy: Bytes!
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

# ============ TRUST ENTITIES ============

type Trust @entity {
  id: ID! # Trust wallet address
  wallet: Wallet! # The wallet that has trust facets
  trustType: TrustType!
  status: TrustStatus!
  
  # Core info (stored on-chain)
  trustInstrumentHash: Bytes! # Hash of trust document
  dateEstablished: BigInt!
  isRevocable: Boolean!
  
  # Participants
  grantor: Bytes! # Primary grantor address
  trustees: [Bytes!]! # Current trustees
  successorTrustees: [Bytes!]! # Successor trustees in order
  beneficiaries: [Bytes!]! # All beneficiaries
  protectors: [Bytes!]! # Trust protectors
  
  # Token reference (for beneficial interest tokens)
  beneficialInterestToken: Token # The token representing beneficial interests
  
  # Accounting totals
  totalDistributed: BigInt!
  totalDistributionsClaimed: BigInt!
  
  # Participants
  participantCount: Int!
  participants: [TrustParticipant!]! @derivedFrom(field: "trust")
  
  # Distributions
  distributions: [Distribution!]! @derivedFrom(field: "trust")
  
  # Milestones
  milestones: [TrustMilestone!]! @derivedFrom(field: "trust")
  
  # Vesting schedules
  vestingSchedules: [TrustVestingSchedule!]! @derivedFrom(field: "trust")
  
  createdAt: BigInt!
  createdTx: Bytes!
}

enum TrustType {
  REVOCABLE_LIVING   # Can be modified by grantor during lifetime
  IRREVOCABLE        # Cannot be modified once created
  TESTAMENTARY       # Created by will, activated upon death
  CHARITABLE         # For charitable purposes
  SPECIAL_NEEDS      # For disabled beneficiaries
  SPENDTHRIFT        # Protects from beneficiary creditors
  OTHER              # Other trust types
}

enum TrustStatus {
  ACTIVE             # Trust is active
  SUSPENDED          # Temporarily suspended
  TERMINATED         # Trust has been terminated
}

type TrustParticipant @entity {
  id: ID! # trust-participant-address
  trust: Trust!
  participantAddress: Bytes!
  role: TrustParticipantRole!
  
  # Beneficiary-specific fields
  benefitPercentage: Int # Basis points (10000 = 100%)
  
  # Token ownership (for tokenized beneficial interests)
  tokenBalance: BigInt # Current beneficial interest token balance
  
  addedAt: BigInt!
  addedTx: Bytes!
  
  # Track if participant has been removed
  removed: Boolean!
  removedAt: BigInt
  removedTx: Bytes
}

enum TrustParticipantRole {
  GRANTOR
  TRUSTEE
  SUCCESSOR_TRUSTEE
  BENEFICIARY
  PROTECTOR
}

type TrustMilestone @entity {
  id: ID! # trust-milestoneId (bytes32)
  trust: Trust!
  milestoneId: Bytes! # bytes32 milestone identifier
  beneficiary: Bytes!
  description: String!
  distributionAmount: BigInt!
  token: Bytes! # Token to distribute
  
  # State
  achieved: Boolean!
  achievedAt: BigInt
  achievedTx: Bytes
  attestedBy: Bytes # Who attested the milestone
  
  # Claim state
  claimed: Boolean!
  claimedAt: BigInt
  claimedTx: Bytes
  
  createdAt: BigInt!
  createdTx: Bytes!
}

type TrustVestingSchedule @entity {
  id: ID! # trust-beneficiary-address
  trust: Trust!
  beneficiary: Bytes!
  token: Bytes! # Token being vested
  
  # Schedule parameters
  totalAmount: BigInt!
  releasedAmount: BigInt!
  startTime: BigInt!
  duration: BigInt!
  cliffDuration: BigInt!
  
  # State
  revoked: Boolean!
  revokedAt: BigInt
  revokedTx: Bytes
  
  createdAt: BigInt!
  createdTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

# Unified Activity Feed
type Activity @entity {
  id: ID! # tx-hash-logIndex or unique identifier
  type: ActivityType!
  wallet: Bytes! # The wallet this activity relates to (for filtering)
  timestamp: BigInt! # Universal timestamp for sorting
  tx: Bytes!
  blockNumber: BigInt!
  
  # Polymorphic references (only one will be set based on type)
  investment: Investment
  offering: Offering
  corporateAction: CorporateAction
  documentSignature: DocumentSignature
  document: Document
  offeringDocumentSignature: OfferingDocumentSignature
  kycStatus: KYCStatus
  classification: InvestorClassification
  lot: Lot
  attestation: Attestation # Hybrid EAS support - kept for backward compatibility
  assetTransfer: AssetTransfer # Native asset transfers (ETH, USDC)
  optionGrant: OptionGrant # Equity compensation option grants
  
  # Vehicle/Trust distribution references
  distribution: Distribution
  distributionClaim: DistributionClaim
  trust: Trust
  trustMilestone: TrustMilestone
  trustVestingSchedule: TrustVestingSchedule
}

# Tracks native asset transfers (ETH, USDC, etc.)
type AssetTransfer @entity {
  id: ID! # activity-id (same as parent activity)
  activity: Activity! @derivedFrom(field: "assetTransfer")
  asset: String! # "ETH" or token address (e.g., USDC address)
  assetSymbol: String! # "ETH", "USDC", etc.
  amount: BigInt! # Raw amount in smallest units (wei for ETH, 6 decimals for USDC)
  amountFormatted: BigDecimal! # Human-readable amount
  counterparty: Bytes! # The other party (recipient for sends, sender for receives)
  direction: TransferDirection!
}

enum TransferDirection {
  IN
  OUT
}

enum ActivityType {
  INVESTMENT_MADE
  INVESTMENT_RECEIVED
  INVESTMENT_COUNTERSIGNED
  INVESTMENT_REJECTED
  OFFCHAIN_INVESTMENT_RECORDED
  OFFCHAIN_INVESTMENT_CONFIRMED
  OFFCHAIN_INVESTMENT_CANCELLED
  OFFERING_CREATED
  OFFERING_COMPLETED
  OFFERING_CANCELLED
  OFFERING_URI_UPDATED
  PAYMENT_RECIPIENT_UPDATED
  PRICE_PER_TOKEN_UPDATED
  DEADLINE_EXTENDED
  MIN_MAX_INVESTMENT_UPDATED
  CORPORATE_ACTION
  DOCUMENT_SIGNED
  DOCUMENT_UPLOADED
  DOCUMENT_CREATED
  KYC_STATUS_UPDATED
  KYC_REVOKED
  CLASSIFICATION_UPDATED
  CLASSIFICATION_REVOKED
  ATTESTATION_RECEIVED # Deprecated - kept for backward compatibility
  LOT_ISSUED # When issuer issues tokens to a recipient
  LOT_RECEIVED # When recipient receives tokens
  LOT_TRANSFERRED
  # Vehicle activities
  CAPITAL_CONTRIBUTED
  DISTRIBUTION_CREATED
  DISTRIBUTION_CLAIMED
  MEMBER_ADDED
  MEMBER_REMOVED
  # Authorized signer activities
  SIGNER_ADDED
  SIGNER_REMOVED
  SIGNER_SUSPENDED
  SIGNER_REINSTATED
  SIGNER_ROLE_UPDATED
  SIGNER_EXPIRY_UPDATED
  # Native asset activities
  ETH_SENT # Outgoing ETH transfer from wallet
  ETH_RECEIVED # Incoming ETH transfer to wallet
  USDC_SENT # Outgoing USDC transfer from wallet
  USDC_RECEIVED # Incoming USDC transfer to wallet
  # Trust activities
  TRUST_CREATED
  TRUST_DISTRIBUTION_CREATED
  TRUST_DISTRIBUTION_CLAIMED
  TRUST_PARTICIPANT_ADDED
  TRUST_PARTICIPANT_REMOVED
  TRUST_MILESTONE_CREATED
  TRUST_MILESTONE_ACHIEVED
  TRUST_VESTING_CREATED
  TRUST_VESTING_RELEASED
  TRUST_REVOKED
  TRUST_STATUS_CHANGED
  # Distribution cancellation
  DISTRIBUTION_CANCELLED
  # Equity compensation activities
  OPTION_GRANTED
  OPTION_EXERCISED
  RSA_GRANTED
}

type Offering @entity {
  id: ID! # Offering address
  issuer: Bytes!
  admin: Bytes! # Admin address for access control
  token: Token # Nullable, reference to any token type via interface
  paymentToken: Bytes!
  paymentRecipient: Bytes!
  pricePerToken: BigInt!
  minInvestment: BigInt!
  maxAmount: BigInt!
  deadline: BigInt!
  totalInvested: BigInt!
  investorCount: BigInt!
  status: OfferingStatus!
  deployer: Bytes! # Address that deployed the offering
  createdAt: BigInt!
  createdTx: Bytes!
  uri: String # Optional metadata URI
  complianceModules: [Bytes!]! # Compliance modules used
  
  # Compliance settings
  generalSolicitation: Boolean
  allowsSelfCertification: Boolean
  
  # Representative signing settings
  documentSignerRoleId: Int # Role ID required for representative document signing (default: 50)
  
  # Document eligibility settings
  documentEligibilityMode: Int # 0=EXPLICIT_LIST, 1=WHITELISTED_ONLY, 2=COMPLIANT_ONLY, 3=CUSTOM_MODULE (default: 2)
  customEligibilityModule: Bytes # Custom eligibility module address (if mode = 3)
  
  # Offchain investment tracking
  totalOffchainPending: BigInt # Nullable for backwards compatibility
  totalOffchainConfirmed: BigInt # Nullable for backwards compatibility
  
  # Relationships
  investments: [Investment!]! @derivedFrom(field: "offering")
  offchainInvestments: [OffchainInvestment!]! @derivedFrom(field: "offering")
  requiredTemplate: OfferingTemplate # The required template for this offering
  documents: [OfferingDocument!]! @derivedFrom(field: "offering") # Document instances created from the template
  documentRequirements: [DocumentRequirement!]! @derivedFrom(field: "offering") # Document requirement groups
}

# Document requirement group for offerings
type DocumentRequirement @entity {
  id: ID! # offering-index (e.g., "0x123...abc-0")
  offering: Offering!
  index: Int! # Index in the requirements array
  label: String!
  allowedTemplateIds: [Bytes!]! # Template IDs that satisfy this requirement
  isRequired: Boolean!
  minRequired: Int! # Minimum number of documents to sign from this group
  maxRequired: Int! # Maximum number of documents allowed from this group
  priority: Int! # Signing order priority (lower number = sign first)
  addedAt: BigInt!
  addedTx: Bytes!
}

# Document template stored in offering contract
type OfferingTemplate @entity {
  id: ID! # templateId (bytes32 as hex string)
  offering: Offering! # The offering this template belongs to
  contentHash: Bytes!
  storageURI: String
  title: String!
  category: String
  creator: Bytes!
  createdAt: BigInt!
  createdTx: Bytes!
  eligibility: SignerEligibility # Set when this template is made required
  
  # Relationships
  documents: [OfferingDocument!]! @derivedFrom(field: "template") # Documents created from this template
  signatures: [OfferingDocumentSignature!]! @derivedFrom(field: "template") # All signatures on documents from this template
  requiredSigners: [RequiredSigner!]! @derivedFrom(field: "template") # Explicit list of required signers (for EXPLICIT_LIST mode)
}

# Required signer for a template (for EXPLICIT_LIST eligibility mode)
type RequiredSigner @entity {
  id: ID! # template-signer (e.g., "0xtemplate-0xsigner")
  template: OfferingTemplate # Nullable to handle cases where template hasn't been indexed yet
  signer: Bytes!
  addedAt: BigInt!
  addedTx: Bytes!
  isActive: Boolean! # false if removed
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

# Document instance created from a template (stored in offering contract)
type OfferingDocument @entity {
  id: ID! # documentId (bytes32 as hex string)
  offering: Offering!
  template: OfferingTemplate # Nullable to handle cases where template hasn't been indexed yet
  title: String!
  creator: Bytes!
  createdAt: BigInt!
  createdTx: Bytes!
  
  # Relationships
  signatures: [OfferingDocumentSignature!]! @derivedFrom(field: "document")
}

# Signature on an offering document
type OfferingDocumentSignature @entity {
  id: ID! # tx-hash-logIndex
  offering: Offering!
  template: OfferingTemplate # Nullable to handle race conditions during indexing
  document: OfferingDocument # Nullable to handle cases where signature is created before document
  signer: Bytes! # The primary signer (entity for representative signatures, individual otherwise)
  signedAt: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
  logIndex: BigInt!
  
  # Representative signing fields
  actualSigner: Bytes # The individual who physically signed (for representative signatures)
  onBehalfOf: Bytes # The entity on whose behalf it was signed
  isDelegated: Boolean! # True if actualSigner signed on behalf of onBehalfOf
}

enum OfferingStatus {
  DRAFT
  ACTIVE
  COMPLETED
  CANCELLED
}

enum EscrowStatus {
  DRAFT
  ACTIVE
  PENDING
  FUNDED
  COMPLETED
  CANCELLED
  DISPUTED
}

enum SignerEligibility {
  COMPLIANT_ONLY
  WHITELISTED_ONLY
  CUSTOM_MODULE
  EXPLICIT_LIST
}

enum InvestmentStatus {
  PENDING
  ACCEPTED
  REJECTED
}

# Lookup table for finding investments by compositeId
type InvestmentLookup @entity {
  id: ID! # offering-investmentId (compositeId)
  investment: Investment! # Points to the actual investment entity
}

# Tracks unique investors per offering (for accurate investor count)
type OfferingInvestor @entity {
  id: ID! # offering-investor (e.g., "0xoffering-0xinvestor")
  offering: Offering!
  investor: Wallet!
  firstInvestedAt: BigInt!
  investmentCount: Int! # Number of investments by this investor in this offering
}

type Investment @entity {
  id: ID! # tx-hash-logIndex (unique event identifier)
  compositeId: String! # offering-investmentId (for protocol lookups)
  offering: Offering!
  investor: Wallet!
  investmentId: BigInt! # Protocol's internal investment ID
  amount: BigInt!
  tokenQuantity: BigInt!
  investedAt: BigInt!
  investedTx: Bytes!
  investedBlockNumber: BigInt!
  
  # Representative signing for investment
  actualInvestor: Wallet # The individual who physically made the investment (for entity investments)
  investedOnBehalfOf: Wallet # The entity on whose behalf the investment was made
  isInvestmentDelegated: Boolean! # True if actualInvestor invested on behalf of investedOnBehalfOf
  
  # Status management
  status: InvestmentStatus!
  
  # Countersign data (when status = ACCEPTED)
  countersignedAt: BigInt
  countersignedTx: Bytes
  countersignedBy: Wallet # The individual who physically countersigned
  countersignedOnBehalfOf: Wallet # The entity on whose behalf countersigning happened
  isCountersignDelegated: Boolean # True if countersignedBy signed on behalf of countersignedOnBehalfOf
  
  # Rejection data (when status = REJECTED)
  rejectedAt: BigInt
  rejectedTx: Bytes
  
  # Attestations
  identityUID: Bytes!
  qualificationUID: Bytes!
}

type OffchainInvestment @entity {
  id: ID! # offering-investmentId (compositeId for protocol lookups)
  offering: Offering!
  investor: Wallet!
  investmentId: BigInt! # Protocol's internal investment ID
  amount: BigInt!
  tokenQuantity: BigInt!
  paymentMethod: String!
  referenceId: String!
  recordedAt: BigInt!
  recordedTx: Bytes!
  recordedBlockNumber: BigInt!
  recordedBy: Bytes! # Admin who recorded it
  
  # Status management
  status: OffchainInvestmentStatus!
  
  # Confirmation data (when status = CONFIRMED)
  confirmedAt: BigInt
  confirmedTx: Bytes
  confirmedBy: Bytes
  
  # Cancellation data (when status = CANCELLED)
  cancelledAt: BigInt
  cancelledTx: Bytes
  cancelledBy: Bytes
}

enum OffchainInvestmentStatus {
  PENDING
  CONFIRMED
  CANCELLED
}

# ============ ESCROW ENTITIES ============

type Escrow @entity {
  id: ID! # Escrow address
  address: Bytes!
  seller: Bytes!
  buyer: Bytes
  arbiter: Bytes
  price: BigInt!
  status: EscrowStatus!
  
  # Creation data
  createdAt: BigInt!
  createdAtBlock: BigInt!
  transactionHash: Bytes!
  
  # Lifecycle timestamps
  activatedAt: BigInt
  activatedAtBlock: BigInt
  cancelledAt: BigInt
  cancelledAtBlock: BigInt
  offerAcceptedAt: BigInt
  offerAcceptedAtBlock: BigInt
  fundedAt: BigInt
  fundedAtBlock: BigInt
  disputeRaisedAt: BigInt
  disputeRaisedAtBlock: BigInt
  disputeRaisedBy: Bytes
}

# ============ TOKEN ENTITIES ============

# Interface for all token types (common fields)
interface Token {
  id: ID! # Token address
  name: String!
  symbol: String!
  decimals: Int!
  totalSupply: BigInt!
  admin: Bytes! # The issuer/owner of the token (company's smart account)
  createdAt: BigInt!
  createdTx: Bytes!
  assetType: TokenAssetType!
  tokenCategory: TokenCategory! # High-level category (EQUITY, DEBT, CONVERTIBLE, DERIVATIVE)
  complianceConditions: [Bytes!]! # Compliance conditions used
  
  # Admin state (from TokenAdminFacet)
  paused: Boolean!
  frozenAccounts: [Bytes!]!
  frozenLots: [Bytes!]!
  retired: Boolean! # Token has been retired (soft flag)
  retiredAt: BigInt # Timestamp when retired (null if not retired)
  
  # Transfer conditions (legacy - deprecated, use complianceModules instead)
  transferController: Bytes
  hasTransferConditions: Boolean!
  
  # Compliance Modules
  complianceModules: [TokenComplianceConfig!]!
  
  # Relationships
  lots: [Lot!]!
  offerings: [Offering!]!
}

enum TokenCategory {
  EQUITY      # Represents ownership: ShareClass, MembershipUnit, FundUnit, SPVUnit
  DEBT        # Represents liability: PromissoryNote, Bond, ConvertibleNote
  CONVERTIBLE # Hybrid instruments: SAFE (converts to equity)
  DERIVATIVE  # Options and warrants: EmployeeStockOption, Warrant, StockAppreciationRight
}

# ShareClass tokens (equity shares and membership units)
type ShareClass implements Token @entity {
  id: ID!
  name: String!
  symbol: String!
  decimals: Int!
  totalSupply: BigInt!
  admin: Bytes!
  createdAt: BigInt!
  createdTx: Bytes!
  assetType: TokenAssetType!
  tokenCategory: TokenCategory!
  cfiCode: Bytes # ISO 10962 Classification of Financial Instruments code (6 bytes)
  complianceConditions: [Bytes!]!
  paused: Boolean!
  frozenAccounts: [Bytes!]!
  frozenLots: [Bytes!]!
  retired: Boolean!
  retiredAt: BigInt
  transferController: Bytes
  hasTransferConditions: Boolean!
  complianceModules: [TokenComplianceConfig!]! @derivedFrom(field: "token")
  lots: [Lot!]! @derivedFrom(field: "token")
  offerings: [Offering!]! @derivedFrom(field: "token")
  
  # Metadata URI (from TokenMetadataFacet)
  baseURI: String # Base URI for token metadata
  
  # ShareClass-specific fields (from TokenAdminFacet)
  maxSupply: BigInt! # 0 = unlimited (from TokenAdminFacet)
  
  # Corporate actions (from TokenCorporateActionsFacet)
  splitNum: BigInt! # Cumulative split numerator
  splitDen: BigInt! # Cumulative split denominator
  divNum: BigInt! # Cumulative dividend numerator
  divDen: BigInt! # Cumulative dividend denominator
  totalSplits: Int! # Count of splits applied
  totalDividends: Int! # Count of dividends applied
  isPublic: Boolean! # Whether entity is SEC registered
  
  # Access control (from AccessControlFacet)
  roleMembers: [TokenRoleMember!]! @derivedFrom(field: "token")
  
  # Corporate action history
  corporateActions: [CorporateAction!]! @derivedFrom(field: "token")
  
  # Option grants for this equity token (for fully diluted cap table)
  optionGrants: [OptionGrant!]! @derivedFrom(field: "equityToken")
}

# Token role membership tracking
type TokenRoleMember @entity {
  id: ID! # token-user-role (e.g., "0x123...abc-0x456...def-1")
  token: ShareClass!
  user: Bytes!
  role: Int! # uint8 role ID
  enabled: Boolean!
  grantedAt: BigInt!
  grantedTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

# Corporate action history tracking
type CorporateAction @entity {
  id: ID! # tx-logIndex (e.g., "0x123...abc-5")
  token: ShareClass!
  actionType: CorporateActionType!
  numerator: BigInt! # Split/dividend numerator
  denominator: BigInt! # Split/dividend denominator
  reducesBasis: Boolean # For dividends only, whether cost basis reduces
  timestamp: BigInt!
  tx: Bytes!
}

enum CorporateActionType {
  StockSplit
  StockDividend
}

# Email-gated token claims
type TokenClaim @entity {
  id: ID! # claimId (bytes32)
  token: ShareClass!
  emailHash: Bytes!
  quantity: BigInt!
  expiresAt: BigInt!
  redeemed: Boolean!
  issuer: Bytes!
  recipient: Bytes # null until redeemed
  lotId: Bytes # null until redeemed
  createdAt: BigInt!
  createdTx: Bytes!
  redeemedAt: BigInt # null until redeemed
  redeemedTx: Bytes # null until redeemed
}

# ============ EQUITY COMPENSATION ============

# 409A Valuation tracking for equity tokens
type Valuation409A @entity {
  id: ID! # token-valuationId
  token: ShareClass!
  valuationId: BigInt!
  pricePerShare: BigInt!
  effectiveDate: BigInt!
  expirationDate: BigInt!
  reportHash: Bytes!
  valuationFirm: Bytes # Optional attestation firm
  recordedBy: Bytes!
  recordedAt: BigInt!
  recordedTx: Bytes!
  invalidatedAt: BigInt
  invalidatedTx: Bytes
  isValid: Boolean!
}

# Stock Option grants
type OptionGrant @entity {
  id: ID! # token-grantId
  equityToken: ShareClass! # Token diamond address (named for UI compatibility)
  grantId: BigInt!
  lotId: Bytes! # Associated lot ID
  recipient: Wallet! # Recipient wallet
  optionType: OptionType!
  status: OptionStatus!
  totalShares: BigInt!
  exercisedShares: BigInt!
  strikePrice: BigInt!
  grantDate: BigInt!
  expirationDate: BigInt!
  vestingDuration: BigInt # Optional - may not be in event
  cliffDuration: BigInt # Optional - may not be in event
  earlyExercise: Boolean # Optional - may not be in event
  election83bHash: Bytes
  election83bDeadline: BigInt
  grantedBy: Bytes! # Who granted the option
  grantTx: Bytes!
  blockNumber: BigInt!
  
  # Exercise history
  exercises: [OptionExercise!]! @derivedFrom(field: "grant")
}

enum OptionType {
  ISO
  NSO
}

enum OptionStatus {
  GRANTED
  PARTIALLY_EXERCISED
  FULLY_EXERCISED
  FORFEITED
  EXPIRED
  CANCELLED
}

# Option exercise events
type OptionExercise @entity {
  id: ID! # tx-logIndex
  grant: OptionGrant!
  sharesExercised: BigInt!
  paymentAmount: BigInt!
  paymentToken: Bytes!
  equityLotId: Bytes! # Lot created on equity token
  exercisedAt: BigInt!
  exerciseTx: Bytes!
}

# RSU grants
type RSUGrant @entity {
  id: ID! # rsuPlan-grantId
  rsuPlan: Bytes! # Address of the RSU plan diamond
  grantId: BigInt!
  recipient: Bytes!
  equityToken: ShareClass!
  companyWallet: Wallet
  status: RSUStatus!
  totalShares: BigInt!
  settledShares: BigInt!
  grantDate: BigInt!
  settlementDate: BigInt
  vestingDuration: BigInt!
  cliffDuration: BigInt!
  grantTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
  
  # Settlement history
  settlements: [RSUSettlement!]! @derivedFrom(field: "grant")
}

enum RSUStatus {
  GRANTED
  PARTIALLY_SETTLED
  FULLY_SETTLED
  FORFEITED
  CANCELLED
}

# RSU settlement events
type RSUSettlement @entity {
  id: ID! # tx-logIndex
  grant: RSUGrant!
  sharesSettled: BigInt!
  equityLotId: Bytes! # Lot created on equity token
  settledAt: BigInt!
  settlementTx: Bytes!
}

# Rule 701 company-level tracking
type Rule701Status @entity {
  id: ID! # companyWallet address
  companyWallet: Wallet!
  totalAssets: BigInt!
  assetReportHash: Bytes!
  aggregate12MonthValue: BigInt! # Rolling 12-month grant value
  currentLimit: BigInt! # Max of $1M or 15% of assets
  remainingCapacity: BigInt!
  disclosureRequired: Boolean!
  disclosureHash: Bytes
  disclosureProvidedAt: BigInt
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
  
  # Registered equity tokens
  equityTokens: [Rule701EquityToken!]! @derivedFrom(field: "rule701Status")
  
  # All grants (options and RSUs)
  grants: [Rule701Grant!]! @derivedFrom(field: "rule701Status")
}

type Rule701EquityToken @entity {
  id: ID! # companyWallet-token
  rule701Status: Rule701Status!
  token: ShareClass!
  registeredAt: BigInt!
  registeredTx: Bytes!
}

type Rule701Grant @entity {
  id: ID! # companyWallet-grantId
  rule701Status: Rule701Status!
  internalGrantId: BigInt!
  equityToken: ShareClass!
  grantValue: BigInt!
  grantType: String! # "ISO_option", "NSO_option", "RSU"
  recipient: Bytes!
  sourcePlan: Bytes! # Option/RSU plan address
  grantDate: BigInt!
  grantTx: Bytes!
}

# ============ SAFE TOKENS ============

# SAFE tokens (Simple Agreement for Future Equity)
# COMMENTED OUT - Will implement in Phase 4
# type Safe implements Token @entity {
#   id: ID!
#   name: String!
#   symbol: String!
#   decimals: Int!
#   totalSupply: BigInt!
#   admin: Bytes!
#   creator: Bytes!
#   deployer: Bytes!
#   createdAt: BigInt!
#   createdTx: Bytes!
#   assetType: TokenAssetType!
#   complianceConditions: [Bytes!]!
#   paused: Boolean!
#   frozenAccounts: [Bytes!]!
#   frozenLots: [Bytes!]!
#   transferController: Bytes
#   hasTransferConditions: Boolean!
#   lots: [Lot!]! @derivedFrom(field: "token")
#   offerings: [Offering!]! @derivedFrom(field: "token")
#   
#   # SAFE-specific fields (from TokenSAFEFacet)
#   issuer: Bytes!
#   defaultValuationCap: BigInt! # 0 = no cap
#   defaultDiscountRate: BigInt! # Basis points (e.g., 2000 = 20%)
#   defaultProRataRight: Boolean!
#   defaultTargetEquityToken: Bytes! # Which share class this converts to
#   defaultHasMFN: Boolean! # Most Favored Nation clause
#   
#   # Conversions
#   conversions: [SAFEConversion!]! @derivedFrom(field: "safe")
# }

# Employee Stock Options
# COMMENTED OUT - Will implement in Phase 4
# type EmployeeStockOption implements Token @entity {
#   id: ID!
#   name: String!
#   symbol: String!
#   decimals: Int!
#   totalSupply: BigInt! # Pool size
#   admin: Bytes!
#   creator: Bytes!
#   deployer: Bytes!
#   createdAt: BigInt!
#   createdTx: Bytes!
#   assetType: TokenAssetType!
#   complianceConditions: [Bytes!]!
#   paused: Boolean!
#   frozenAccounts: [Bytes!]!
#   frozenLots: [Bytes!]!
#   transferController: Bytes
#   hasTransferConditions: Boolean!
#   lots: [Lot!]! @derivedFrom(field: "token")
#   offerings: [Offering!]! @derivedFrom(field: "token")
#   
#   # ESO-specific fields (from TokenESOFacet)
#   issuer: Bytes!
#   underlyingShareClass: ShareClass # Which share class these options are for
#   defaultExercisePrice: BigInt!
#   defaultExpirationPeriod: BigInt! # Seconds after grant
#   poolSize: BigInt! # Total options allocated to pool
#   optionsGranted: BigInt! # Options already granted
#   optionsExercised: BigInt! # Options exercised
#   
#   # Grants
#   grants: [ESOGrant!]! @derivedFrom(field: "option")
# }

# Stock Appreciation Rights
# COMMENTED OUT - Will implement in Phase 4
# type StockAppreciationRight implements Token @entity {
#   id: ID!
#   name: String!
#   symbol: String!
#   decimals: Int!
#   totalSupply: BigInt! # Pool size
#   admin: Bytes!
#   deployer: Bytes!
#   createdAt: BigInt!
#   createdTx: Bytes!
#   assetType: TokenAssetType!
#   complianceConditions: [Bytes!]!
#   paused: Boolean!
#   frozenAccounts: [Bytes!]!
#   frozenLots: [Bytes!]!
#   transferController: Bytes
#   hasTransferConditions: Boolean!
#   lots: [Lot!]! @derivedFrom(field: "token")
#   offerings: [Offering!]! @derivedFrom(field: "token")
#   
#   # SAR-specific fields (from TokenSARFacet)
#   issuer: Bytes!
#   underlyingShareClass: ShareClass # Which share class these SARs reference
#   basePrice: BigInt! # Base price for appreciation calculation
#   settlementType: String! # "Cash" or "Shares"
#   poolSize: BigInt! # Total SARs allocated to pool
#   sarsGranted: BigInt! # SARs already granted
#   sarsExercised: BigInt! # SARs exercised
#   
#   # Grants
#   grants: [SARGrant!]! @derivedFrom(field: "sar")
# }

enum TokenAssetType {
  ShareClass # Corporate common/preferred shares
  MembershipUnit # LLC/DAO membership units
  UnitInterest # LP unit interests (for investment vehicles)
  Safe # Simple Agreement for Future Equity
  PromissoryNote # Debt instrument (loans, bonds, notes)
  DaoToken # DAO governance token
  TokenizedAsset # Tokenized real-world asset
  # Future token types (commented out until implemented):
  # EmployeeStockOption
  # Warrant
  # StockAppreciationRight
}

# SAFE Token Type
type Safe implements Token @entity {
  # Token interface fields
  id: ID! # Token address
  name: String!
  symbol: String!
  decimals: Int!
  totalSupply: BigInt!
  creator: Bytes! # Kept for backwards compatibility
  admin: Bytes!
  deployer: Bytes!
  createdAt: BigInt!
  createdTx: Bytes!
  assetType: TokenAssetType!
  cfiCode: Bytes # ISO 10962 CFI code (6 bytes)
  tokenCategory: TokenCategory!
  
  # Compliance
  complianceConditions: [Bytes!]! # Compliance conditions used
  
  # Admin state
  paused: Boolean!
  frozenAccounts: [Bytes!]!
  frozenLots: [Bytes!]!
  retired: Boolean!
  retiredAt: BigInt
  transferController: Bytes
  hasTransferConditions: Boolean!
  complianceModules: [TokenComplianceConfig!]! @derivedFrom(field: "token")
  lots: [Lot!]! @derivedFrom(field: "token")
  offerings: [Offering!]! @derivedFrom(field: "token")
  
  # Metadata URI (from TokenMetadataFacet)
  baseURI: String # Base URI for token metadata
  
  # SAFE-specific fields
  defaultValuationCap: BigInt! # Default valuation cap (0 = uncapped)
  defaultDiscountRate: Int! # Default discount rate in basis points
  defaultTargetEquityToken: Bytes! # Default ShareClass to convert into
  defaultProRataRight: Boolean! # Default pro-rata participation rights
  defaultHasMFN: Boolean! # Default Most Favored Nation clause
  
  # Statistics
  totalInvested: BigInt!
  totalConverted: BigInt!
  lotsConverted: Int!
  
  # Conversions
  conversions: [SAFEConversion!]! @derivedFrom(field: "safe")
}

# SAFE Conversion tracking
type SAFEConversion @entity {
  id: ID! # tx-hash-logIndex
  safe: Safe!
  safeLot: Lot! # The SAFE lot being converted
  investor: Bytes!
  investmentAmount: BigInt!
  sharesIssued: BigInt!
  effectivePrice: BigInt!
  targetShareClass: Bytes! # ShareClass token address
  equityLotId: Bytes! # The new equity lot created
  conversionNote: String!
  convertedAt: BigInt!
  convertedTx: Bytes!
  blockNumber: BigInt!
  logIndex: BigInt!
}

# ============ PROMISSORY NOTE TOKEN TYPE ============

# Promissory Note Token Type (Debt Instrument)
type PromissoryNote implements Token @entity {
  # Token interface fields
  id: ID! # Token address
  name: String!
  symbol: String!
  decimals: Int!
  totalSupply: BigInt!
  creator: Bytes! # Kept for backwards compatibility
  admin: Bytes!
  deployer: Bytes!
  createdAt: BigInt!
  createdTx: Bytes!
  assetType: TokenAssetType!
  cfiCode: Bytes # ISO 10962 CFI code (6 bytes)
  tokenCategory: TokenCategory!
  
  # Compliance
  complianceConditions: [Bytes!]! # Compliance conditions used
  
  # Admin state
  paused: Boolean!
  frozenAccounts: [Bytes!]!
  frozenLots: [Bytes!]!
  retired: Boolean!
  retiredAt: BigInt
  transferController: Bytes
  hasTransferConditions: Boolean!
  complianceModules: [TokenComplianceConfig!]! @derivedFrom(field: "token")
  lots: [Lot!]! @derivedFrom(field: "token")
  offerings: [Offering!]! @derivedFrom(field: "token")
  
  # Metadata URI (from TokenMetadataFacet)
  baseURI: String # Base URI for token metadata
  uri: String # Deprecated: use baseURI instead
  
  # Debt-specific fields
  principalAmount: BigInt! # Original principal (same as totalSupply for debt)
  interestRate: Int! # Annual rate in basis points (500 = 5%, 0 = no interest)
  issuanceDate: BigInt! # When debt was issued
  maturityDate: BigInt! # When repayment is due
  paymentCurrency: Bytes! # Currency for payments (address(0) for ETH)
  paymentType: DebtPaymentType! # BULLET, AMORTIZING, INTEREST_ONLY
  isSubordinated: Boolean! # True if subordinated debt (e.g., founder notes)
  gracePeriodDays: Int! # Days after maturity before default
  
  # Debtor tracking
  debtor: Bytes! # Company/borrower wallet address
  creditor: Bytes! # Token holder (lender) wallet address
  
  # Payment tracking
  totalPaid: BigInt!
  principalPaid: BigInt!
  interestPaid: BigInt!
  outstandingBalance: BigInt!
  
  # Status
  status: DebtStatus!
  isMatured: Boolean!
  isDefaulted: Boolean!
  defaultedAt: BigInt
  
  # Relationships
  payments: [DebtPayment!]! @derivedFrom(field: "note")
}

enum DebtPaymentType {
  BULLET # Single payment at maturity
  AMORTIZING # Regular principal + interest payments
  INTEREST_ONLY # Regular interest, principal at maturity
}

enum DebtStatus {
  ACTIVE # Debt is active and accruing
  PAID_OFF # Fully repaid
  DEFAULTED # In default
  EXTENDED # Maturity extended
}

# Debt Payment tracking
type DebtPayment @entity {
  id: ID! # tx-hash-logIndex
  note: PromissoryNote!
  payer: Bytes! # Who made the payment
  amount: BigInt! # Total payment amount
  principalPortion: BigInt! # Amount applied to principal
  interestPortion: BigInt! # Amount applied to interest
  remainingBalance: BigInt! # Outstanding balance after payment
  paidAt: BigInt!
  paidTx: Bytes!
  blockNumber: BigInt!
  logIndex: BigInt!
}

# ============ FUTURE TOKEN TYPES ============

# FUTURE: ESO Grant tracking (uncomment when implementing ESO tokens)
# type ESOGrant @entity {
#   id: ID! # option-grant-index
#   option: EmployeeStockOption!
#   grantee: Wallet!
#   lot: Lot! # The ESO lot for this grant
#   quantity: BigInt!
#   exercisePrice: BigInt!
#   grantedAt: BigInt!
#   cliffDate: BigInt!
#   expirationDate: BigInt!
#   vestedAmount: BigInt!
#   exercisedAmount: BigInt!
#   isRevoked: Boolean!
#   revokedAt: BigInt
# }

# FUTURE: SAR Grant tracking (uncomment when implementing SAR tokens)
# type SARGrant @entity {
#   id: ID! # sar-grant-index
#   sar: StockAppreciationRight!
#   grantee: Wallet!
#   lot: Lot! # The SAR lot for this grant
#   quantity: BigInt!
#   basePrice: BigInt!
#   grantedAt: BigInt!
#   cliffDate: BigInt!
#   expirationDate: BigInt!
#   vestedAmount: BigInt!
#   exercisedAmount: BigInt!
#   isRevoked: Boolean!
#   revokedAt: BigInt
# }

# Transfer Conditions (vesting, lockups, etc.)
type TransferCondition @entity {
  id: ID! # token-condition-index
  token: Token! # Can apply to any token type
  conditionType: TransferConditionType!
  account: Bytes!
  lot: Lot # Optional: specific to a lot
  
  # Vesting-specific fields
  startDate: BigInt
  cliffDate: BigInt
  endDate: BigInt
  totalAmount: BigInt
  claimedAmount: BigInt!
  
  # State
  revoked: Boolean!
  revokedAt: BigInt
  
  createdAt: BigInt!
  createdTx: Bytes!
}

enum TransferConditionType {
  Vesting
  Lockup
  Custom
}

# ============ COMPLIANCE MODULES ============

# Compliance module registry - tracks all compliance modules used across tokens
type ComplianceModule @entity {
  id: ID! # module-address
  address: Bytes!
  name: String!
  version: String!
  moduleType: String! # "HoldingPeriod", "VolumeLimit", "AffiliateStatus", "Vesting", "Lockup", "Custom"
  firstUsedAt: BigInt!
  firstUsedTx: Bytes!
  
  # Relationships
  tokens: [TokenComplianceConfig!]! @derivedFrom(field: "module")
}

# Token-level compliance configuration - which modules are active for each token
type TokenComplianceConfig @entity {
  id: ID! # token-module
  token: Token!
  module: ComplianceModule!
  isGlobal: Boolean! # True if applies to all lots, false if lot-specific
  addedAt: BigInt!
  addedTx: Bytes!
  removedAt: BigInt
  removedTx: Bytes
  isActive: Boolean! # False if removed
}

# Lot-specific module assignment (overrides or additions to global modules)
type LotComplianceConfig @entity {
  id: ID! # lot-module
  lot: Lot!
  module: ComplianceModule!
  addedAt: BigInt!
  addedTx: Bytes!
}

# ============ MODULE-SPECIFIC ENTITIES ============

# Holding Period Module - tracks acquisition dates and required holding periods
type HoldingPeriodConfig @entity {
  id: ID! # token-lotId-holder
  token: Token!
  lotId: Bytes! # bytes32 lot identifier
  holder: Bytes!
  module: ComplianceModule! # Reference to the HoldingPeriodModule instance
  holdingPeriod: BigInt! # Required holding period in seconds (from token-level config)
  acquisitionDate: BigInt! # When holder acquired this lot
  unlockDate: BigInt! # Calculated: acquisitionDate + holdingPeriod
  isUnlocked: Boolean! # True if current time >= unlockDate
  
  # Tracking
  createdAt: BigInt!
  createdTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

# Volume Limit Module - tracks rolling volume limits for affiliates
type VolumeLimitConfig @entity {
  id: ID! # token-holder
  token: Token!
  holder: Bytes!
  module: ComplianceModule! # Reference to the VolumeLimitModule instance
  
  # Configuration (from token-level settings)
  limitBps: Int! # Basis points (100 = 1%, 10000 = 100%)
  windowSeconds: BigInt! # Time window for volume tracking
  
  # Current window state
  currentWindowStart: BigInt! # When current window started
  currentVolume: BigInt! # Cumulative volume in current window
  lastTransferAt: BigInt # Last time volume was recorded
  
  # Tracking
  createdAt: BigInt!
  createdTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

# Affiliate Status Module - tracks which holders are affiliates
type AffiliateStatus @entity {
  id: ID! # token-holder
  token: Token!
  holder: Bytes!
  module: ComplianceModule! # Reference to the AffiliateStatusModule instance
  isAffiliate: Boolean!
  affiliateSince: BigInt # When holder became affiliate (null if never was)
  affiliateUntil: BigInt # When holder stopped being affiliate (null if currently is)
  
  # History tracking
  statusChanges: [AffiliateStatusChange!]! @derivedFrom(field: "affiliateStatus")
  
  # Tracking
  createdAt: BigInt!
  createdTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

# History of affiliate status changes
type AffiliateStatusChange @entity {
  id: ID! # tx-hash-logIndex
  affiliateStatus: AffiliateStatus!
  becameAffiliate: Boolean! # True if became affiliate, false if revoked
  changedAt: BigInt!
  changedTx: Bytes!
}

# Lockup Compliance Module - tracks time-based lockups per lot
type LockupConfig @entity {
  id: ID! # lotId (bytes32 as hex string)
  lotId: Bytes! # bytes32 lot identifier
  unlockTime: BigInt! # Unix timestamp when lot becomes transferable
  
  # Tracking
  createdAt: BigInt!
  createdTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

# Vesting Compliance Module - tracks vesting schedules per lot
type VestingConfig @entity {
  id: ID! # lotId (bytes32 as hex string)
  lotId: Bytes! # bytes32 lot identifier
  holder: Bytes! # Token holder address
  totalBasisPoints: BigInt! # Percentage of lot to vest (10000 = 100%)
  releasedBasisPoints: BigInt! # Percentage already released
  startTime: BigInt! # Vesting start timestamp
  duration: BigInt! # Total vesting duration in seconds
  cliffDuration: BigInt! # Cliff period in seconds
  revocable: Boolean! # Whether the schedule can be revoked
  revoked: Boolean! # Whether the schedule has been revoked
  
  # Tracking
  createdAt: BigInt!
  createdTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

type Lot @entity {
  id: ID! # token-lotId
  token: Token! # Can reference any token type via interface
  lotId: BigInt!
  owner: Wallet!
  quantity: BigInt! # Raw quantity (before corporate actions). To get real quantity: quantity * token.splitNum * token.divNum / (token.splitDen * token.divDen)
  costBasis: BigInt! # Total cost basis for this lot (total investment amount, not per-token). Use paymentDecimals to convert to display value.
  acquisitionDate: BigInt!
  createdAt: BigInt! # Alias for acquisitionDate
  acquiredFrom: Bytes!
  parentLotId: BigInt # For lot splits/transfers
  assetId: String # Token identifier
  paymentCurrency: Bytes # Currency used for acquisition
  paymentDecimals: Int # Decimals of the payment currency
  customId: BigInt # Custom ID for user-friendly lot identification
  uri: String # URI of the lot
  isValid: Boolean! # Whether the lot is active (false if burned/invalidated)
  data: Bytes # Additional data associated with the lot
  transferType: String # Transfer type (INTERNAL, SALE, GIFT, INHERITANCE, INCOME)
  metadata: String
  
  # Adjustment history
  adjustedFrom: Lot # Reference to parent lot if this was created via adjustment
  adjustments: [LotAdjustment!]! @derivedFrom(field: "lot")
  
  # State
  frozen: Boolean!
  frozenAt: BigInt
  
  # Compliance
  lotSpecificModules: [LotComplianceConfig!]! @derivedFrom(field: "lot") # Lot-specific compliance modules (in addition to token's global modules)
  
  # Type-specific references (optional - uncomment as needed)
  # esoGrant: ESOGrant # If this is an ESO grant lot
  # sarGrant: SARGrant # If this is a SAR grant lot
  # safeConversion: SAFEConversion # If this lot was created from SAFE conversion
}

type LotAdjustment @entity {
  id: ID! # tx-hash-logIndex
  oldLot: Lot!
  newLot: Lot!
  operator: Bytes!
  owner: Bytes!
  newQuantity: BigInt!
  newCostBasis: BigInt!
  paymentCurrency: Bytes!
  acquisitionDate: BigInt!
  uri: String!
  data: Bytes!
  reason: String!
  transferType: String!
  adjustedCostBasis: BigInt! # The delta in cost basis
  timestamp: BigInt!
  transaction: Bytes!
  lot: Lot! # For reverse lookup
}

type CustomIdUpdate @entity {
  id: ID! # tx-hash-logIndex
  lot: Lot!
  oldCustomId: BigInt!
  newCustomId: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

# ============ PRE-APPROVED TERMS (Offering-specific) ============

# Interface for all pre-approved term types
interface PreApprovedTerms {
  id: ID! # offering-investor
  offering: Offering!
  investor: Bytes!
  encodedTerms: Bytes! # Raw encoded data
  assetType: TokenAssetType!
  setAt: BigInt!
  setTx: Bytes!
  setBy: Bytes! # Admin who set the terms
  cleared: Boolean!
  clearedAt: BigInt
  clearedTx: Bytes
  clearedBy: Bytes
}

# SAFE-specific pre-approved terms
type SafePreApprovedTerms implements PreApprovedTerms @entity {
  id: ID! # offering-investor
  offering: Offering!
  investor: Bytes!
  encodedTerms: Bytes!
  assetType: TokenAssetType!
  setAt: BigInt!
  setTx: Bytes!
  setBy: Bytes!
  cleared: Boolean!
  clearedAt: BigInt
  clearedTx: Bytes
  clearedBy: Bytes
  
  # SAFE-specific decoded fields
  valuationCap: BigInt! # 0 = uncapped
  discountRate: Int! # Basis points (e.g., 2000 = 20%)
  interestRate: Int! # Basis points (e.g., 500 = 5%)
  maturityDate: BigInt! # Unix timestamp, 0 = no maturity
}

# ============ COMPLIANCE (ComplianceStorage-based) ============

type KYCStatus @entity {
  id: ID! # offering-address-wallet-address (e.g., "0x123...abc-0x456...def")
  offering: Offering!
  wallet: Wallet!
  verified: Boolean!
  expirationTime: BigInt!
  verifiedBy: Bytes!
  updatedAt: BigInt!
  updatedTx: Bytes!
  revoked: Boolean!
  revokedAt: BigInt
  revokedTx: Bytes
  revokedBy: Bytes
}

type InvestorClassification @entity {
  id: ID! # offering-address-wallet-address-classification (e.g., "0x123...abc-0x456...def-ACCREDITED_INVESTOR")
  offering: Offering!
  wallet: Wallet!
  classification: String! # Classification string (e.g., "ACCREDITED_INVESTOR", "NON_ACCREDITED_INVESTOR")
  classificationHash: Bytes! # bytes32 hash for compatibility
  addedAt: BigInt!
  addedTx: Bytes!
  addedBy: Bytes!
  revoked: Boolean!
  revokedAt: BigInt
  revokedTx: Bytes
  revokedBy: Bytes
}

# Deprecated: Old EAS-based attestations (kept for backward compatibility)
type Attestation @entity {
  id: ID! # attestation UID
  schema: Bytes! # Schema UID
  attester: Bytes!
  wallet: Wallet! # The wallet this attestation is about
  data: Bytes!
  createdAt: BigInt!
  expiresAt: BigInt
  revoked: Boolean!
  revokedAt: BigInt
  
  # Decoded fields for unified investor schema: (address offering, bool isVerified, bytes32[] classifications)
  offering: Bytes # Offering address (0x0 = universal/global attestation)
  isVerified: Boolean # KYC/identity verification status
  classifications: [Bytes!]! # Investor classifications (e.g., ACCREDITED, NON_ACCREDITED, SOPHISTICATED)
}

# ============ FACET REGISTRY ============

type Facet @entity {
  id: ID! # Facet address
  name: String!
  version: BigInt!
  selectors: [String!]!
  createdAt: BigInt!
  createdTx: Bytes!
  deploymentSalt: Bytes # Salt used for CREATE2 deployment (if deployed via registry)
  removed: Boolean!
  removedAt: BigInt
  removedTx: Bytes
}

type FacetRegistryEvent @entity {
  id: ID! # tx-logIndex
  eventType: FacetRegistryEventType!
  facet: Bytes!
  facetName: String!
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
  
  # For FacetDeployed events
  deploymentSalt: Bytes
  selectors: [String!]
}

enum FacetRegistryEventType {
  REGISTERED
  REMOVED
  DEPLOYED
}

# ============ INSTALLED FACETS (Diamond Config Tracking) ============

# Tracks which facets are currently installed on a diamond
type InstalledFacet @entity {
  id: ID! # diamond-facetAddress (e.g., "0xwallet-0xfacet")
  diamond: Diamond!
  facetAddress: Bytes!
  facetName: String # Resolved from registry if known
  selectors: [String!]! # Function selectors routed to this facet
  action: FacetCutAction! # How it was installed (ADD, REPLACE)
  installedAt: BigInt!
  installedTx: Bytes!
  installedBlock: BigInt!
  
  # Version tracking (resolved from registry)
  version: BigInt # Null if facet not in registry
  
  # Current state
  isActive: Boolean! # False if removed
  removedAt: BigInt
  removedTx: Bytes
}

# Historical record of all diamond cuts
type DiamondCutEvent @entity {
  id: ID! # tx-logIndex
  diamond: Diamond!
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
  
  # Cut details
  facetAddress: Bytes!
  action: FacetCutAction!
  selectors: [String!]!
  
  # Initialization (if any)
  initAddress: Bytes
  initCalldata: Bytes
}

enum FacetCutAction {
  ADD
  REPLACE
  REMOVE
}

# ============ PAYMENT TOKENS ============

# Generic ERC20 token entity (reusable across offerings, factories, etc.)
type PaymentToken @entity {
  id: ID! # Token address
  address: Bytes!
  symbol: String!
  decimals: Int!
  name: String!
  
  # Where this token is used
  factoryConfigs: [FactoryPaymentTokenConfig!]! @derivedFrom(field: "paymentToken")
  
  createdAt: BigInt!
  createdTx: Bytes!
}

# ============ FACTORY PAYMENT TRACKING ============

type FactoryPaymentConfig @entity {
  id: ID! # factory-address
  factory: Bytes!
  factoryType: FactoryType! # TOKEN, OFFERING, WALLET
  feeRecipient: Bytes!
  paymentsEnabled: Boolean!
  deploymentCount: BigInt!
  
  # Payment token configurations
  paymentTokens: [FactoryPaymentTokenConfig!]! @derivedFrom(field: "factoryConfig")
  
  # Payments collected
  payments: [FactoryPayment!]! @derivedFrom(field: "factory")
  
  createdAt: BigInt!
  createdTx: Bytes!
}

# Factory-specific configuration for a payment token
type FactoryPaymentTokenConfig @entity {
  id: ID! # factory-token
  factoryConfig: FactoryPaymentConfig!
  paymentToken: PaymentToken! # Reference to the token entity
  feeAmount: BigInt!
  isActive: Boolean!
  totalCollected: BigInt!
  
  configuredAt: BigInt!
  configuredTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

type FactoryPayment @entity {
  id: ID! # tx-logIndex
  factory: FactoryPaymentConfig!
  payer: Bytes!
  paymentToken: Bytes!
  amount: BigInt!
  deploymentType: String! # "Token", "Offering", "Wallet"
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

# Factory payment discount tracking
type FactoryPaymentDiscount @entity {
  id: ID! # factory-user
  factory: Bytes!
  user: Bytes!
  discountBasisPoints: BigInt! # 10000 = 100% discount (free)
  setAt: BigInt!
  setTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

enum FactoryType {
  DIAMOND
  TOKEN
  OFFERING
  WALLET
}
