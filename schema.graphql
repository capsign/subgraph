type Diamond @entity {
  id: ID! # Diamond address
  diamondType: String! # WALLET, OFFERING, TOKEN
  creator: Bytes! # User/deployer who initiated the creation
  createdAt: BigInt!
  createdTx: Bytes!
  
  # Factory settings (for factory diamonds)
  facetRegistry: Bytes # Address of FacetRegistry (only for factory diamonds)
  
  # Polymorphic relationships (optional - diamonds may be tracked separately)
  wallet: Wallet
  offering: Offering
  token: Token # Can reference any token type via interface
  
  # Access control
  userRoles: [UserRole!]! @derivedFrom(field: "diamond")
  functionAccess: [FunctionAccess!]! @derivedFrom(field: "diamond")
  
  # Installed facets (diamond configuration)
  installedFacets: [InstalledFacet!]! @derivedFrom(field: "diamond")
  cutHistory: [DiamondCutEvent!]! @derivedFrom(field: "diamond")
}

# System configuration - single entity with id "system"
type SystemConfig @entity {
  id: ID! # Always "system"
  diamondFactory: Bytes! # Address of DiamondFactory
  facetRegistry: Bytes! # Address of FacetRegistry
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}


# Generic access control tracking for all diamonds
type UserRole @entity {
  id: ID! # diamond-user-role (e.g., "0x123...abc-0x456...def-1")
  diamond: Diamond!
  user: Bytes!
  role: Int! # uint8 role ID
  enabled: Boolean!
  grantedAt: BigInt!
  grantedTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

type UserRoleHistory @entity {
  id: ID! # tx-logIndex (unique per event)
  diamond: Diamond!
  user: Bytes!
  role: Int! # uint8 role ID
  enabled: Boolean! # true = granted, false = revoked
  changedBy: Bytes! # Transaction sender (admin who made the change)
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

type FunctionAccess @entity {
  id: ID! # diamond-functionSelector-role (e.g., "0x123...abc-0x12345678-1")
  diamond: Diamond!
  functionSelector: Bytes! # bytes4 function selector
  role: Int! # uint8 role ID
  hasAccess: Boolean! # true if role has access, false if revoked
  grantedAt: BigInt!
  grantedTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

type Wallet @entity {
  id: ID! # Wallet address (all CapSign wallets are ERC-4337 smart accounts)
  deployer: Bytes! # Address that deployed the wallet
  createdAt: BigInt!
  createdTx: Bytes!
  
  # Owners (full control - governance layer)
  owners: [Owner!]! @derivedFrom(field: "wallet")
  
  # Authorized Signers (role-limited - operational layer)
  signers: [AuthorizedSigner!]! @derivedFrom(field: "wallet")
  
  # UserOperation Executions (audit trail)
  executions: [UserOperationExecution!]! @derivedFrom(field: "wallet")
  
  # Documents
  documents: [Document!]! @derivedFrom(field: "wallet")
  
  # Relationships
  tokens: [Lot!]! @derivedFrom(field: "owner")
  investments: [Investment!]! @derivedFrom(field: "investor")
  kycStatus: KYCStatus
  classifications: [InvestorClassification!]! @derivedFrom(field: "wallet")
  
  # Access Manager - contracts this wallet manages
  managedContracts: [AuthorityDelegation!]! @derivedFrom(field: "authorityWallet")
  targetPermissions: [TargetFunctionPermission!]! @derivedFrom(field: "managerWallet")
  
  # Vehicle/Trust profiles (if wallet has these facets)
  vehicle: Vehicle
  trust: Trust
  
  # Entity classification (GLEIF ELF codes)
  entityClassification: EntityClassification
  
  # Liens granted on this wallet's assets
  liens: [Lien!]! @derivedFrom(field: "wallet")
  isFrozen: Boolean! # Whether wallet is frozen by any lien
  
  # DeFi vault positions (treasury management)
  vaultPositions: [VaultPosition!]! @derivedFrom(field: "wallet")
  registeredVaults: [DeFiVault!]! @derivedFrom(field: "wallet")
  
  # Redemption control (gates, suspensions, side pockets)
  redemptionRequests: [RedemptionRequest!]! @derivedFrom(field: "wallet")
  sidePockets: [SidePocket!]! @derivedFrom(field: "wallet")
}

# ============ ENTITY CLASSIFICATION (GLEIF ELF Codes) ============

type EntityClassification @entity {
  id: ID! # Wallet address
  wallet: Wallet!
  
  # GLEIF ELF Code (Entity Legal Form)
  elfCode: Bytes! # 4-byte ELF code (e.g., 0x384d4a54 for "8MJT" = Delaware LLC)
  elfName: String! # Human-readable name (e.g., "Delaware LLC")
  
  # Legal Entity Identifier (optional)
  lei: Bytes # 20-character LEI (null if not registered)
  
  # Jurisdiction
  jurisdictionCode: Bytes! # 2-byte ISO 3166-1 alpha-2 (e.g., "US")
  jurisdictionSub: String # State/province (e.g., "DE" for Delaware)
  
  # Formation
  formationDate: BigInt # Unix timestamp (0 or null if unknown)
  
  # Timestamps
  createdAt: BigInt!
  createdTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

# ============ LIEN ENTITIES ============

enum LienStatus {
  ACTIVE
  RELEASED
  REVOKED
}

type Lien @entity {
  id: ID! # wallet-lienId (e.g., "0xwallet-0xlienid")
  wallet: Wallet! # The wallet with the lien
  lienId: Bytes! # bytes32 lien identifier
  lienHolder: Bytes! # Address with lien control
  
  # Collateral configuration
  collateralTokens: [Bytes!]! # Token addresses (empty = all assets)
  maxSeizureAmount: BigInt! # 0 = unlimited
  totalSeized: BigInt! # Running total seized
  
  # Timing
  grantedAt: BigInt!
  grantedTx: Bytes!
  expiresAt: BigInt! # 0 = no expiry
  
  # External reference (loan ID, UCC filing, etc.)
  externalRef: String!
  
  # Status
  status: LienStatus!
  isFrozen: Boolean! # Whether this lien has frozen the wallet
  
  # Termination info (if released/revoked)
  terminatedAt: BigInt
  terminatedTx: Bytes
  terminatedBy: Bytes
  
  # Seizure history
  seizures: [AssetSeizure!]! @derivedFrom(field: "lien")
  
  # Freeze/unfreeze history
  freezeEvents: [WalletFreezeEvent!]! @derivedFrom(field: "lien")
}

type AssetSeizure @entity {
  id: ID! # tx-logIndex
  lien: Lien!
  token: Bytes! # Token address seized
  amount: BigInt!
  recipient: Bytes!
  reason: String!
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

type WalletFreezeEvent @entity {
  id: ID! # tx-logIndex
  lien: Lien!
  wallet: Wallet!
  isFrozen: Boolean! # true = freeze, false = unfreeze
  actor: Bytes! # Who triggered the event
  reason: String # Only for freeze events
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

# Tracks which wallet (AccessManager) has authority over a contract (AccessManaged)
type AuthorityDelegation @entity {
  id: ID! # managedContract-authorityWallet (e.g., "0xtoken-0xwallet")
  managedContract: Bytes! # The token/offering diamond being managed
  authorityWallet: Wallet! # The wallet diamond acting as AccessManager
  setAt: BigInt!
  setTx: Bytes!
  previousAuthority: Bytes # Previous authority address (or null if first time)
}

# Tracks permissions configured by a wallet for calling functions on managed contracts
type TargetFunctionPermission @entity {
  id: ID! # managerWallet-target-selector (e.g., "0xwallet-0xtoken-0x12345678")
  managerWallet: Wallet! # The wallet that manages this permission
  targetContract: Bytes! # The contract (token/offering) this permission applies to
  functionSelector: Bytes! # bytes4 function selector
  requiredRole: Int! # uint8 role ID required on the manager wallet
  setAt: BigInt!
  setTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

type Owner @entity {
  id: ID! # wallet-address or wallet-publicKeyHash
  wallet: Wallet!
  ownerType: OwnerType!
  address: Bytes # For EOA and MPC owners
  publicKey: Bytes # For Passkey owners (64 bytes: x + y coordinates)
  publicKeyHash: Bytes # For Passkey owners (hash for indexing)
  addedAt: BigInt!
  addedTx: Bytes!
}

enum OwnerType {
  EOA
  Passkey
  MPC
}

# ============ AUTHORIZED SIGNERS ============
# Role-limited signers separate from full wallet owners
# Enables separation of governance (owners) from operations (signers)

type AuthorizedSigner @entity {
  id: ID! # wallet-signerId
  wallet: Wallet!
  signerId: Bytes! # bytes32 keccak256 of credentials
  signerType: SignerType!
  address: Bytes # For EOA signers
  publicKeyX: BigInt # For Passkey signers
  publicKeyY: BigInt # For Passkey signers
  roleId: Int! # Role limiting signer's access
  validUntil: BigInt # Expiry timestamp (0 = no expiry)
  isActive: Boolean!
  label: String
  addedAt: BigInt!
  addedTx: Bytes!
  removedAt: BigInt
  removedTx: Bytes
  
  # Executions by this signer
  executions: [UserOperationExecution!]! @derivedFrom(field: "signer")
}

enum SignerType {
  EOA
  Passkey
}

# Tracks each UserOperation execution for audit trail
type UserOperationExecution @entity {
  id: ID! # tx-hash-logIndex
  wallet: Wallet!
  userOpHash: Bytes!
  signer: AuthorizedSigner # null if owner executed
  signerId: Bytes! # bytes32(0) for owners, signerId for signers
  signerRole: Int! # 0 = admin/owner
  target: Bytes!
  functionSelector: Bytes!
  success: Boolean!
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
  logIndex: BigInt!
}

type Document @entity {
  id: ID! # Raw documentId (bytes32 as hex string)
  wallet: Wallet!
  contentHash: Bytes!
  storageURI: String!
  category: String!
  title: String!
  creator: Bytes!
  createdAt: BigInt!
  createdTx: Bytes!
  requiredSigners: [Bytes!]!
  
  # Parent-child relationship for template-based documents
  parentDocument: Document # Reference to template document (null if this is a template)
  childDocuments: [Document!]! @derivedFrom(field: "parentDocument") # Documents created from this template
  
  # Signatures
  signatures: [DocumentSignature!]! @derivedFrom(field: "document")
}

type DocumentSignature @entity {
  id: ID! # tx-hash-logIndex
  document: Document # Nullable to handle cases where DocumentSigned event is indexed before DocumentCreated
  signer: Bytes! # The primary signer (entity for representative signatures, individual otherwise)
  signedAt: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
  logIndex: BigInt!
  
  # Representative signing fields
  actualSigner: Bytes # The individual who physically signed (for representative signatures)
  onBehalfOf: Bytes # The entity on whose behalf it was signed
  isDelegated: Boolean! # True if actualSigner signed on behalf of onBehalfOf
}

# ============ PAYMASTER ENTITIES ============

type PaymasterPolicy @entity {
  id: ID! # Wallet address
  wallet: Wallet!
  enabled: Boolean!
  dailyBudget: BigInt!
  paymasterAddress: Bytes!
  
  # Policy configuration history
  configurations: [PaymasterPolicyConfiguration!]! @derivedFrom(field: "policy")
  
  # Role policies
  rolePolicies: [RolePolicy!]! @derivedFrom(field: "policy")
  
  # Spending tracking
  sponsoredTransactions: [SponsoredTransaction!]! @derivedFrom(field: "entityPolicy")
  totalSponsored: BigInt!
  
  updatedAt: BigInt!
  updatedTx: Bytes!
}

type PaymasterPolicyConfiguration @entity {
  id: ID! # tx-hash-logIndex
  policy: PaymasterPolicy!
  enabled: Boolean!
  dailyBudget: BigInt!
  paymasterAddress: Bytes!
  timestamp: BigInt!
  tx: Bytes!
}

type RolePolicy @entity {
  id: ID! # wallet-address-role
  policy: PaymasterPolicy!
  role: Int!
  canBeSponsored: Boolean!
  dailyLimit: BigInt!
  allowedOperations: [Bytes!]!
  updatedAt: BigInt!
  updatedTx: Bytes!
}

type SponsoredTransaction @entity {
  id: ID! # tx-hash-logIndex
  entityPolicy: PaymasterPolicy!
  entity: Bytes! # Entity wallet address
  user: Bytes! # User who was sponsored
  actualCost: BigInt! # Gas cost in wei
  refunded: BigInt! # Amount refunded to paymaster
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

type PaymasterDeposit @entity {
  id: ID! # tx-hash-logIndex
  entity: Bytes!
  amount: BigInt!
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

type PaymasterWithdrawal @entity {
  id: ID! # tx-hash-logIndex
  entity: Bytes!
  recipient: Bytes!
  amount: BigInt!
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

type PolicyCheckFailure @entity {
  id: ID! # tx-hash-logIndex
  entity: Bytes!
  user: Bytes!
  reason: String!
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

# ============ VEHICLE (SPV/Fund) ENTITIES ============

type Vehicle @entity {
  id: ID! # Vehicle wallet address
  wallet: Wallet! # The wallet that has vehicle facets
  vehicleType: VehicleType! # SPV, FUND, DAO
  
  # Funding mode configuration
  fundingMode: FundingMode! # COMMITMENT, DIRECT, or HYBRID
  isOpenEnded: Boolean! # Whether investors can redeem at NAV
  
  # Capital accounting totals
  totalCapitalCommitted: BigInt! # Sum of all member commitments
  totalCapitalCalled: BigInt! # Sum of all capital calls issued
  totalCapitalContributed: BigInt! # Actual $ received
  totalDistributionsExecuted: BigInt!
  totalDistributionsClaimed: BigInt!
  
  # Fee tracking
  managementFeeRate: BigInt # Basis points (200 = 2%)
  carryRate: BigInt # Basis points (2000 = 20%)
  hurdleRate: BigInt # Basis points (800 = 8%)
  accruedManagementFees: BigInt! # Fees accrued but not yet settled
  totalManagementFeesPaid: BigInt! # Total fees paid to GP (stablecoin)
  lastFeeAccrualAt: BigInt # Timestamp of last fee accrual
  
  # Token reference (for unit interest tokens)
  # NOTE: Members are derived from token lots (lot.owner where quantity > 0)
  token: Token # The UNIT_INTEREST token representing ownership
  
  # Member commitments (subscription-level tracking)
  memberCommitments: [MemberCommitment!]! @derivedFrom(field: "vehicle")
  
  # Capital contributions
  contributions: [CapitalContribution!]! @derivedFrom(field: "vehicle")
  
  # Capital calls
  capitalCalls: [CapitalCall!]! @derivedFrom(field: "vehicle")
  
  # Distributions
  distributions: [Distribution!]! @derivedFrom(field: "vehicle")
  
  # Investments (if SPV)
  investments: [VehicleInvestment!]! @derivedFrom(field: "vehicle")
  
  createdAt: BigInt!
  createdTx: Bytes!
}

# ============ MEMBER COMMITMENT (Subscription-Level) ============
# Tracks an LP's overall commitment to a vehicle, spanning all capital calls.
# Tokens are minted only when capital is actually funded, not at subscription.

type MemberCommitment @entity {
  id: ID! # vehicle-memberAddress
  vehicle: Vehicle!
  member: Wallet! # The LP's wallet
  memberAddress: Bytes! # Address for easy querying
  
  # Amounts (in payment token, typically 6 decimals for USDC)
  totalCommitted: BigInt! # Original subscription amount
  totalCalled: BigInt! # Sum of capital calls issued to this member
  totalFunded: BigInt! # Actual $ contributed
  totalTokensMinted: BigInt! # LP tokens minted (should track with totalFunded)
  
  # Unfunded commitment
  unfundedCommitment: BigInt! # totalCommitted - totalFunded
  
  # Ownership percentage (updated when tokens minted)
  ownershipBps: BigInt! # Basis points of fund ownership (1000 = 10%)
  
  # Status
  status: MemberCommitmentStatus!
  
  # Lifecycle timestamps
  subscribedAt: BigInt! # When commitment was made
  admittedAt: BigInt # When GP accepted subscription
  firstFundingAt: BigInt # When first capital was contributed
  lastFundingAt: BigInt # Most recent contribution
  defaultedAt: BigInt # If defaulted on a capital call
  withdrawnAt: BigInt # If withdrew from fund
  
  # Per-call tracking
  callCommitments: [CallCommitment!]! @derivedFrom(field: "memberCommitment")
  
  # Contribution history
  contributions: [CapitalContribution!]! @derivedFrom(field: "memberCommitment")
  
  # Metadata
  createdAt: BigInt!
  createdTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

enum MemberCommitmentStatus {
  PENDING    # Subscription signed, awaiting GP acceptance
  ACTIVE     # In good standing
  DEFAULTED  # Failed to meet capital call obligation
  CANCELLED  # GP cancelled before any funding
  WITHDRAWN  # LP withdrew (redeemed all tokens)
}

# ============ FEE TRACKING ENTITIES ============

type FeeAccrualEvent @entity {
  id: ID! # tx-logIndex
  vehicle: Vehicle!
  amount: BigInt! # Fee amount accrued in this event
  feeBase: BigInt! # Value fees were calculated on (NAV, committed, or called)
  daysAccrued: BigInt! # Number of days in this accrual
  totalAccrued: BigInt! # Total accrued fees after this event
  timestamp: BigInt!
  tx: Bytes!
}

type FeeSettlementEvent @entity {
  id: ID! # tx-logIndex
  vehicle: Vehicle!
  amount: BigInt! # Stablecoin fee amount paid
  recipient: Bytes! # GP wallet that received payment
  timestamp: BigInt!
  tx: Bytes!
}

enum VehicleType {
  SPV        # Special Purpose Vehicle (single investment)
  FUND       # Multi-investment fund
  DAO        # DAO LLC
}

enum FundingMode {
  COMMITMENT   # Traditional PE/VC with capital calls
  DIRECT       # Immediate investment at NAV
  HYBRID       # Both modes available
}

# Fund Membership Model:
# Membership is derived from token ownership (Lot entities where quantity > 0).
# Ownership percentage = lot.quantity / token.totalSupply
# Capital contributions are tracked via CallContribution entities.
# Distributions received are tracked via DistributionClaim entities.

type CapitalContribution @entity {
  id: ID! # tx-hash-logIndex
  vehicle: Vehicle!
  memberCommitment: MemberCommitment # Link to subscription commitment
  memberAddress: Bytes! # Address of the contributing member
  amount: BigInt!
  tokensMinted: BigInt! # LP tokens minted for this contribution
  
  # Context: where did this capital come from?
  source: CapitalSource! # OFFERING, DIRECT, TRANSFER, CAPITAL_CALL
  offering: Offering # If source = OFFERING, reference the offering
  capitalCall: CapitalCall # If source = CAPITAL_CALL, reference the call
  callCommitment: CallCommitment # If source = CAPITAL_CALL, reference the specific call commitment
  
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
  logIndex: BigInt!
}

enum CapitalSource {
  OFFERING   # From countersigned investment in an offering
  DIRECT     # Manually recorded contribution
  TRANSFER   # From token transfer (secondary market)
  CAPITAL_CALL # From a capital call
}

# ============ CAPITAL CALL ENTITIES ============

type CapitalCall @entity {
  id: ID! # vehicle-callId
  vehicle: Vehicle!
  callId: BigInt! # Protocol's internal capital call ID
  totalAmount: BigInt!
  totalReceived: BigInt!
  dueDate: BigInt! # Unix timestamp when contributions are due
  purposeHash: Bytes! # IPFS hash or keccak256 of purpose description
  paymentToken: Bytes!
  status: CapitalCallStatus!
  
  # Commitments for each member
  commitments: [CallCommitment!]! @derivedFrom(field: "capitalCall")
  
  # Contributions linked to this call
  contributions: [CallContribution!]! @derivedFrom(field: "capitalCall")
  
  # State
  cancelled: Boolean!
  cancelledAt: BigInt
  cancelledTx: Bytes
  
  createdAt: BigInt!
  createdTx: Bytes!
  blockNumber: BigInt!
}

enum CapitalCallStatus {
  PENDING      # Call created, awaiting contributions
  PARTIAL      # Some contributions received
  FUNDED       # Fully funded (totalReceived >= totalAmount)
  OVERDUE      # Past due date and not fully funded
  CANCELLED    # Call was cancelled
}

type CallCommitment @entity {
  id: ID! # capitalCall-memberAddress
  capitalCall: CapitalCall!
  memberCommitment: MemberCommitment! # Link to parent subscription commitment
  memberAddress: Bytes! # Address of the member with this commitment
  amountDue: BigInt! # Pro-rata amount calculated at call creation
  amountPaid: BigInt! # Amount contributed so far
  tokensMinted: BigInt! # Tokens minted for this call contribution
  status: CallCommitmentStatus!
  
  # Track individual contributions
  contributions: [CallContribution!]! @derivedFrom(field: "commitment")
  
  # Deadline tracking
  dueDate: BigInt! # When payment is due
  paidAt: BigInt # When fully paid
  defaultedAt: BigInt # When marked as defaulted (if applicable)
  
  createdAt: BigInt!
  createdTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

enum CallCommitmentStatus {
  PENDING      # No contributions yet
  PARTIAL      # Some amount paid
  PAID         # Fully paid (amountPaid >= amountDue)
  DEFAULTED    # Failed to pay by due date
}

type CallContribution @entity {
  id: ID! # tx-logIndex
  capitalCall: CapitalCall!
  commitment: CallCommitment!
  memberAddress: Bytes! # Address of the contributing member
  amount: BigInt!
  isOffchain: Boolean! # True if recorded via recordOffchainContribution
  
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
  logIndex: BigInt!
}

# Track incoming ERC20 transfers to fund wallets for auto-matching
type IncomingTransfer @entity {
  id: ID! # tx-logIndex
  wallet: Wallet! # The fund wallet receiving the transfer
  vehicle: Vehicle # Vehicle profile if wallet has one
  from: Bytes! # Sender address
  token: Bytes! # Token address
  amount: BigInt!
  
  # Auto-matching status
  matched: Boolean! # True if matched to a capital call
  matchedCall: CapitalCall # The capital call this was matched to (null if unmatched)
  matchedMemberAddress: Bytes # Address of the member this was matched to (null if unmatched)
  matchedAt: BigInt
  
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
  logIndex: BigInt!
}

type Distribution @entity {
  id: ID! # vehicle-distributionId or trust-distributionId
  vehicle: Vehicle # Vehicle this distribution belongs to (null for trust distributions)
  trust: Trust # Trust this distribution belongs to (null for vehicle distributions)
  distributionId: BigInt! # Protocol's internal distribution ID
  totalAmount: BigInt!
  totalClaimed: BigInt! # Amount claimed so far
  lpAmount: BigInt! # Amount for limited partners (vehicle only)
  carryAmount: BigInt! # Amount for carry recipients (vehicle only)
  
  # Token references (claim-based model)
  paymentToken: Bytes! # Token being distributed (e.g., USDC)
  membershipToken: Bytes # Token determining eligibility (vehicle) or beneficialInterestToken (trust)
  
  # Distribution type (for trusts)
  distributionType: DistributionTypeEnum # INCOME, PRINCIPAL, LIQUIDATING
  
  # State
  cancelled: Boolean!
  cancelledAt: BigInt
  cancelledTx: Bytes
  expiresAt: BigInt # Expiration timestamp (0 = no expiry)
  
  createdAt: BigInt!
  createdTx: Bytes!
  blockNumber: BigInt!
  
  # Individual claims by members/beneficiaries
  claims: [DistributionClaim!]! @derivedFrom(field: "distribution")
}

enum DistributionTypeEnum {
  INCOME       # Regular income (rental, dividends)
  PRINCIPAL    # Return of capital
  LIQUIDATING  # Trust termination
}

type DistributionClaim @entity {
  id: ID! # distribution-claimant-address
  distribution: Distribution!
  claimantAddress: Bytes! # Address of the claimant (member or beneficiary)
  amount: BigInt!
  
  # For vehicle distributions
  isCarryRecipient: Boolean # True if this is a carry (GP) claim
  
  # For trust distributions
  trustParticipant: TrustParticipant # Link to trust participant (if trust distribution)
  
  # State
  claimed: Boolean!
  claimedAt: BigInt
  claimedTx: Bytes
  blockNumber: BigInt
  logIndex: BigInt
}

# ============ ASSET DISPOSAL & CAPITAL GAINS ============

enum DisposalType {
  SALE           # Sold to another party
  REDEMPTION     # Redeemed back to issuer
  DISTRIBUTION   # Distributed to members
  LIQUIDATION    # Full position exit
}

enum TaxStrategy {
  FIFO  # First In First Out
  LIFO  # Last In First Out
  HIFO  # Highest cost basis In First Out
  LOFO  # Lowest cost basis In First Out
}

type AssetDisposal @entity {
  id: ID!                           # txHash-logIndex
  fundWallet: Vehicle!
  token: Token!
  tokenSymbol: String!
  
  # Lot details
  lotIds: [Bytes!]!                 # Array of lot IDs that were disposed
  quantities: [BigInt!]!            # Array of quantities from each lot
  totalUnits: BigDecimal!
  
  # Cost basis (from lots)
  costBasis: BigDecimal!            # Total cost basis
  costBasisPerUnit: BigDecimal!
  
  # Proceeds
  counterparty: Bytes!              # Buyer/recipient of the tokens
  paymentToken: Bytes!
  paymentTokenSymbol: String!
  proceeds: BigDecimal!
  proceedsPerUnit: BigDecimal!
  
  # Gain/Loss calculation
  realizedGain: BigDecimal!         # proceeds - costBasis (can be negative)
  realizedGainPerUnit: BigDecimal!
  isLongTerm: Boolean!              # Based on oldest lot in selection (held > 1 year)
  
  # Tax strategy used
  taxStrategy: TaxStrategy!
  
  # Disposal type
  disposalType: DisposalType!
  
  # Metadata
  timestamp: BigInt!
  txHash: Bytes!
  blockNumber: BigInt!
}

type FundTaxYearSummary @entity {
  id: ID!                           # fundWallet-taxYear
  fundWallet: Vehicle!
  taxYear: Int!
  
  # Short-term gains (held <= 1 year) - K-1 Box 8
  shortTermGains: BigDecimal!
  shortTermLosses: BigDecimal!
  netShortTermGain: BigDecimal!
  
  # Long-term gains (held > 1 year) - K-1 Box 9a
  longTermGains: BigDecimal!
  longTermLosses: BigDecimal!
  netLongTermGain: BigDecimal!
  
  # Ordinary income totals - K-1 Box 1
  ordinaryIncome: BigDecimal!
  interestIncome: BigDecimal!
  dividendIncome: BigDecimal!
  rentalIncome: BigDecimal!
  otherIncome: BigDecimal!
  
  # Wash sale adjustments
  washSaleDisallowed: BigDecimal! # Total losses disallowed due to wash sales
  
  # All disposals this year
  disposals: [AssetDisposal!]!
  
  # Income events
  incomeEvents: [IncomeEvent!]! @derivedFrom(field: "taxYearSummary")
  
  # Wash sales
  washSales: [WashSale!]! @derivedFrom(field: "taxYearSummary")
  
  lastUpdated: BigInt!
}

# ============ INCOME TRACKING ============

enum IncomeType {
  INTEREST     # Interest income (loans, DeFi yields)
  DIVIDEND     # Dividend income from equity holdings
  RENTAL       # Rental income from real estate
  ROYALTY      # Royalty income
  OTHER        # Other ordinary income
}

type IncomeEvent @entity {
  id: ID!                           # txHash-logIndex
  fundWallet: Vehicle!
  taxYearSummary: FundTaxYearSummary
  
  # Income details
  incomeType: IncomeType!
  amount: BigDecimal!
  paymentToken: Bytes!              # Token received (USDC, etc.)
  paymentTokenSymbol: String!
  
  # Source tracking
  sourceAsset: Bytes                # Asset generating income (token address, note address)
  sourceDescription: String         # Human-readable description
  
  # Payer info
  payer: Bytes!                     # Who paid the income
  
  # Timing
  receivedAt: BigInt!
  taxYear: Int!
  
  # Transaction
  txHash: Bytes!
  blockNumber: BigInt!
}

# ============ WASH SALE TRACKING ============

type WashSale @entity {
  id: ID!                           # txHash-logIndex
  fundWallet: Vehicle!
  taxYearSummary: FundTaxYearSummary
  
  # The disposal that triggered the wash sale
  disposal: AssetDisposal!
  
  # Wash sale details
  disallowedLoss: BigDecimal!       # Amount of loss disallowed
  washPurchaseDate: BigInt!         # Date of the wash purchase
  washPurchaseLotId: Bytes!         # Lot ID of the replacement shares
  
  # The loss is added to the basis of the replacement shares
  basisAdjustment: BigDecimal!      # Amount added to replacement lot basis
  
  # 30-day window info
  originalSaleDate: BigInt!
  windowStart: BigInt!              # 30 days before sale
  windowEnd: BigInt!                # 30 days after sale
  
  # Tax year
  taxYear: Int!
  
  # Transaction
  detectedAt: BigInt!
  txHash: Bytes!
  blockNumber: BigInt!
}

type VehicleInvestment @entity {
  id: ID! # vehicle-investmentId
  vehicle: Vehicle!
  investmentId: BigInt! # Protocol's internal investment ID
  assetType: VehicleAssetType!
  
  # Investment details
  target: Bytes! # Address of the investment target (company, protocol, etc.)
  amount: BigInt!
  entryDate: BigInt!
  entryTx: Bytes!
  
  # Exit details (if exited)
  exited: Boolean!
  exitAmount: BigInt
  exitDate: BigInt
  exitTx: Bytes
  
  # Current valuation (updated by vehicle admin)
  currentValuation: BigInt!
  lastValuationUpdate: BigInt!
}

enum VehicleAssetType {
  EQUITY        # Equity investment in a company
  DEBT          # Debt instrument
  CRYPTO        # Cryptocurrency holding
  DEFI          # DeFi protocol position
  REAL_ESTATE   # Real estate holding
  OTHER         # Other asset types
}

# Track NAV updates for the vehicle
type VehicleValuation @entity {
  id: ID! # tx-hash-logIndex
  vehicle: Vehicle!
  totalNAV: BigInt! # Net Asset Value
  navPerToken: BigInt! # NAV divided by total token supply
  
  # Breakdown
  totalAssets: BigInt!
  totalLiabilities: BigInt!
  
  updatedBy: Bytes!
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

# ============ TRUST ENTITIES ============

type Trust @entity {
  id: ID! # Trust wallet address
  wallet: Wallet! # The wallet that has trust facets
  trustType: TrustType!
  status: TrustStatus!
  
  # Core info (stored on-chain)
  trustInstrumentHash: Bytes! # Hash of trust document
  dateEstablished: BigInt!
  isRevocable: Boolean!
  
  # Participants
  grantor: Bytes! # Primary grantor address
  trustees: [Bytes!]! # Current trustees
  successorTrustees: [Bytes!]! # Successor trustees in order
  beneficiaries: [Bytes!]! # All beneficiaries
  protectors: [Bytes!]! # Trust protectors
  
  # Token reference (for beneficial interest tokens)
  beneficialInterestToken: Token # The token representing beneficial interests
  
  # Accounting totals
  totalDistributed: BigInt!
  totalDistributionsClaimed: BigInt!
  
  # Participants
  participantCount: Int!
  participants: [TrustParticipant!]! @derivedFrom(field: "trust")
  
  # Distributions
  distributions: [Distribution!]! @derivedFrom(field: "trust")
  
  # Milestones
  milestones: [TrustMilestone!]! @derivedFrom(field: "trust")
  
  # Vesting schedules
  vestingSchedules: [TrustVestingSchedule!]! @derivedFrom(field: "trust")
  
  createdAt: BigInt!
  createdTx: Bytes!
}

enum TrustType {
  REVOCABLE_LIVING   # Can be modified by grantor during lifetime
  IRREVOCABLE        # Cannot be modified once created
  TESTAMENTARY       # Created by will, activated upon death
  CHARITABLE         # For charitable purposes
  SPECIAL_NEEDS      # For disabled beneficiaries
  SPENDTHRIFT        # Protects from beneficiary creditors
  OTHER              # Other trust types
}

enum TrustStatus {
  ACTIVE             # Trust is active
  SUSPENDED          # Temporarily suspended
  TERMINATED         # Trust has been terminated
}

type TrustParticipant @entity {
  id: ID! # trust-participant-address
  trust: Trust!
  participantAddress: Bytes!
  role: TrustParticipantRole!
  
  # Beneficiary-specific fields
  benefitPercentage: Int # Basis points (10000 = 100%)
  
  # Token ownership (for tokenized beneficial interests)
  tokenBalance: BigInt # Current beneficial interest token balance
  
  addedAt: BigInt!
  addedTx: Bytes!
  
  # Track if participant has been removed
  removed: Boolean!
  removedAt: BigInt
  removedTx: Bytes
}

enum TrustParticipantRole {
  GRANTOR
  TRUSTEE
  SUCCESSOR_TRUSTEE
  BENEFICIARY
  PROTECTOR
}

type TrustMilestone @entity {
  id: ID! # trust-milestoneId (bytes32)
  trust: Trust!
  milestoneId: Bytes! # bytes32 milestone identifier
  beneficiary: Bytes!
  description: String!
  distributionAmount: BigInt!
  token: Bytes! # Token to distribute
  
  # State
  achieved: Boolean!
  achievedAt: BigInt
  achievedTx: Bytes
  attestedBy: Bytes # Who attested the milestone
  
  # Claim state
  claimed: Boolean!
  claimedAt: BigInt
  claimedTx: Bytes
  
  createdAt: BigInt!
  createdTx: Bytes!
}

type TrustVestingSchedule @entity {
  id: ID! # trust-beneficiary-address
  trust: Trust!
  beneficiary: Bytes!
  token: Bytes! # Token being vested
  
  # Schedule parameters
  totalAmount: BigInt!
  releasedAmount: BigInt!
  startTime: BigInt!
  duration: BigInt!
  cliffDuration: BigInt!
  
  # State
  revoked: Boolean!
  revokedAt: BigInt
  revokedTx: Bytes
  
  createdAt: BigInt!
  createdTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

# Unified Activity Feed
type Activity @entity {
  id: ID! # tx-hash-logIndex or unique identifier
  type: ActivityType!
  wallet: Bytes! # The wallet that initiated/owns this activity
  targetWallet: Bytes # The wallet that is the subject/target of this activity (e.g., fund wallet for capital calls)
  timestamp: BigInt! # Universal timestamp for sorting
  tx: Bytes!
  blockNumber: BigInt!
  
  # Polymorphic references (only one will be set based on type)
  investment: Investment
  offering: Offering
  corporateAction: CorporateAction
  documentSignature: DocumentSignature
  document: Document
  offeringDocumentSignature: OfferingDocumentSignature
  kycStatus: KYCStatus
  classification: InvestorClassification
  lot: Lot
  attestation: Attestation # Hybrid EAS support - kept for backward compatibility
  assetTransfer: AssetTransfer # Native asset transfers (ETH, USDC)
  optionGrant: OptionGrant # Equity compensation option grants
  
  # Vehicle/Trust distribution references
  distribution: Distribution
  distributionClaim: DistributionClaim
  trust: Trust
  trustMilestone: TrustMilestone
  trustVestingSchedule: TrustVestingSchedule
  
  # Capital call references
  capitalCall: CapitalCall
  callContribution: CallContribution
  
  # DeFi/Treasury references
  vaultPosition: VaultPosition
  vaultDeposit: VaultDeposit
  vaultWithdrawal: VaultWithdrawal
}

# Tracks native asset transfers (ETH, USDC, etc.)
type AssetTransfer @entity {
  id: ID! # activity-id (same as parent activity)
  activity: Activity! @derivedFrom(field: "assetTransfer")
  asset: String! # "ETH" or token address (e.g., USDC address)
  assetSymbol: String! # "ETH", "USDC", etc.
  amount: BigInt! # Raw amount in smallest units (wei for ETH, 6 decimals for USDC)
  amountFormatted: BigDecimal! # Human-readable amount
  counterparty: Bytes! # The other party (recipient for sends, sender for receives)
  direction: TransferDirection!
}

enum TransferDirection {
  IN
  OUT
}

enum ActivityType {
  INVESTMENT_MADE
  INVESTMENT_RECEIVED
  INVESTMENT_COUNTERSIGNED
  INVESTMENT_REJECTED
  OFFCHAIN_INVESTMENT_RECORDED
  OFFCHAIN_INVESTMENT_CONFIRMED
  OFFCHAIN_INVESTMENT_CANCELLED
  OFFERING_CREATED
  OFFERING_COMPLETED
  OFFERING_CANCELLED
  OFFERING_URI_UPDATED
  PAYMENT_RECIPIENT_UPDATED
  PRICE_PER_TOKEN_UPDATED
  DEADLINE_EXTENDED
  MIN_MAX_INVESTMENT_UPDATED
  CORPORATE_ACTION
  DOCUMENT_SIGNED
  DOCUMENT_UPLOADED
  DOCUMENT_CREATED
  KYC_STATUS_UPDATED
  KYC_REVOKED
  CLASSIFICATION_UPDATED
  CLASSIFICATION_REVOKED
  ATTESTATION_RECEIVED # Deprecated - kept for backward compatibility
  LOT_ISSUED # When issuer issues tokens to a recipient
  LOT_RECEIVED # When recipient receives tokens
  LOT_TRANSFERRED
  # Vehicle activities
  CAPITAL_CONTRIBUTED
  DISTRIBUTION_CREATED
  DISTRIBUTION_CLAIMED
  DISTRIBUTION_PUSHED
  MEMBER_ADDED
  MEMBER_REMOVED
  # Capital call activities
  CAPITAL_CALL_CREATED
  CAPITAL_CALL_CONTRIBUTION
  CAPITAL_CALL_OFFCHAIN_CONTRIBUTION
  CAPITAL_CALL_CANCELLED
  CAPITAL_CALL_FUNDED
  # Commitment activities (mint-at-funding model)
  COMMITMENT_CREATED
  COMMITMENT_ACCEPTED
  COMMITMENT_CANCELLED
  COMMITMENT_DEFAULTED
  CAPITAL_FUNDED
  # Fee activities
  FEE_SETTLED
  CARRY_CALCULATED
  # Authorized signer activities
  SIGNER_ADDED
  SIGNER_REMOVED
  SIGNER_SUSPENDED
  SIGNER_REINSTATED
  SIGNER_ROLE_UPDATED
  SIGNER_EXPIRY_UPDATED
  # Native asset activities
  ETH_SENT # Outgoing ETH transfer from wallet
  ETH_RECEIVED # Incoming ETH transfer to wallet
  USDC_SENT # Outgoing USDC transfer from wallet
  USDC_RECEIVED # Incoming USDC transfer to wallet
  # Trust activities
  TRUST_CREATED
  TRUST_DISTRIBUTION_CREATED
  TRUST_DISTRIBUTION_CLAIMED
  TRUST_PARTICIPANT_ADDED
  TRUST_PARTICIPANT_REMOVED
  TRUST_MILESTONE_CREATED
  TRUST_MILESTONE_ACHIEVED
  TRUST_VESTING_CREATED
  TRUST_VESTING_RELEASED
  TRUST_REVOKED
  TRUST_STATUS_CHANGED
  # Distribution cancellation
  DISTRIBUTION_CANCELLED
  # Equity compensation activities
  OPTION_GRANTED
  OPTION_EXERCISED
  RSA_GRANTED
  # Tax tracking activities
  ASSET_DISPOSED
  INCOME_RECEIVED
  WASH_SALE_DETECTED
  # DeFi/Treasury activities
  VAULT_REGISTERED
  VAULT_UNREGISTERED
  VAULT_DEPOSIT
  VAULT_WITHDRAWAL
  VAULT_VALUATION_UPDATED
  # Redemption control activities
  REDEMPTION_REQUESTED
  REDEMPTION_PROCESSED
  REDEMPTION_CANCELLED
  REDEMPTIONS_SUSPENDED
  REDEMPTIONS_RESUMED
  SIDE_POCKET_CREATED
  SIDE_POCKET_DISTRIBUTED
  GATE_PERIOD_RESET
}

type Offering @entity {
  id: ID! # Offering address
  issuer: Bytes!
  admin: Bytes! # Admin address for access control
  token: Token # Nullable, reference to any token type via interface
  paymentToken: Bytes!
  paymentRecipient: Bytes!
  pricePerToken: BigInt!
  minInvestment: BigInt!
  maxAmount: BigInt!
  deadline: BigInt!
  totalInvested: BigInt!
  totalCommitted: BigInt! # For commitment-based offerings
  isCommitmentBased: Boolean!
  investorCount: BigInt!
  status: OfferingStatus!
  deployer: Bytes! # Address that deployed the offering
  createdAt: BigInt!
  createdTx: Bytes!
  uri: String # Optional metadata URI
  complianceModules: [Bytes!]! # Compliance modules used
  
  # Compliance settings
  generalSolicitation: Boolean
  allowsSelfCertification: Boolean
  
  # Representative signing settings
  documentSignerRoleId: Int # Role ID required for representative document signing (default: 50)
  
  # Document eligibility settings
  documentEligibilityMode: Int # 0=EXPLICIT_LIST, 1=WHITELISTED_ONLY, 2=COMPLIANT_ONLY, 3=CUSTOM_MODULE (default: 2)
  customEligibilityModule: Bytes # Custom eligibility module address (if mode = 3)
  
  # Offchain investment tracking
  totalOffchainPending: BigInt # Nullable for backwards compatibility
  totalOffchainConfirmed: BigInt # Nullable for backwards compatibility
  
  # Relationships
  investments: [Investment!]! @derivedFrom(field: "offering")
  offchainInvestments: [OffchainInvestment!]! @derivedFrom(field: "offering")
  requiredTemplate: OfferingTemplate # The required template for this offering
  documents: [OfferingDocument!]! @derivedFrom(field: "offering") # Document instances created from the template
  documentRequirements: [DocumentRequirement!]! @derivedFrom(field: "offering") # Document requirement groups
}

# Document requirement group for offerings
type DocumentRequirement @entity {
  id: ID! # offering-index (e.g., "0x123...abc-0")
  offering: Offering!
  index: Int! # Index in the requirements array
  label: String!
  allowedTemplateIds: [Bytes!]! # Template IDs that satisfy this requirement
  isRequired: Boolean!
  minRequired: Int! # Minimum number of documents to sign from this group
  maxRequired: Int! # Maximum number of documents allowed from this group
  priority: Int! # Signing order priority (lower number = sign first)
  addedAt: BigInt!
  addedTx: Bytes!
}

# Document template stored in offering contract
type OfferingTemplate @entity {
  id: ID! # templateId (bytes32 as hex string)
  offering: Offering! # The offering this template belongs to
  contentHash: Bytes!
  storageURI: String
  title: String!
  category: String
  creator: Bytes!
  createdAt: BigInt!
  createdTx: Bytes!
  eligibility: SignerEligibility # Set when this template is made required
  
  # Relationships
  documents: [OfferingDocument!]! @derivedFrom(field: "template") # Documents created from this template
  signatures: [OfferingDocumentSignature!]! @derivedFrom(field: "template") # All signatures on documents from this template
  requiredSigners: [RequiredSigner!]! @derivedFrom(field: "template") # Explicit list of required signers (for EXPLICIT_LIST mode)
}

# Required signer for a template (for EXPLICIT_LIST eligibility mode)
type RequiredSigner @entity {
  id: ID! # template-signer (e.g., "0xtemplate-0xsigner")
  template: OfferingTemplate # Nullable to handle cases where template hasn't been indexed yet
  signer: Bytes!
  addedAt: BigInt!
  addedTx: Bytes!
  isActive: Boolean! # false if removed
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

# Document instance created from a template (stored in offering contract)
type OfferingDocument @entity {
  id: ID! # documentId (bytes32 as hex string)
  offering: Offering!
  template: OfferingTemplate # Nullable to handle cases where template hasn't been indexed yet
  title: String!
  creator: Bytes!
  createdAt: BigInt!
  createdTx: Bytes!
  
  # Relationships
  signatures: [OfferingDocumentSignature!]! @derivedFrom(field: "document")
}

# Signature on an offering document
type OfferingDocumentSignature @entity {
  id: ID! # tx-hash-logIndex
  offering: Offering!
  template: OfferingTemplate # Nullable to handle race conditions during indexing
  document: OfferingDocument # Nullable to handle cases where signature is created before document
  signer: Bytes! # The primary signer (entity for representative signatures, individual otherwise)
  signedAt: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
  logIndex: BigInt!
  
  # Representative signing fields
  actualSigner: Bytes # The individual who physically signed (for representative signatures)
  onBehalfOf: Bytes # The entity on whose behalf it was signed
  isDelegated: Boolean! # True if actualSigner signed on behalf of onBehalfOf
}

enum OfferingStatus {
  DRAFT
  ACTIVE
  COMPLETED
  CANCELLED
}

enum EscrowStatus {
  DRAFT
  ACTIVE
  PENDING
  FUNDED
  COMPLETED
  CANCELLED
  DISPUTED
}

enum SignerEligibility {
  COMPLIANT_ONLY
  WHITELISTED_ONLY
  CUSTOM_MODULE
  EXPLICIT_LIST
}

enum InvestmentStatus {
  PENDING
  ACCEPTED
  REJECTED
}

# Lookup table for finding investments by compositeId
type InvestmentLookup @entity {
  id: ID! # offering-investmentId (compositeId)
  investment: Investment! # Points to the actual investment entity
}

# Tracks unique investors per offering (for accurate investor count)
type OfferingInvestor @entity {
  id: ID! # offering-investor (e.g., "0xoffering-0xinvestor")
  offering: Offering!
  investor: Wallet!
  firstInvestedAt: BigInt!
  investmentCount: Int! # Number of investments by this investor in this offering
}

type Investment @entity {
  id: ID! # tx-hash-logIndex (unique event identifier)
  compositeId: String! # offering-investmentId (for protocol lookups)
  offering: Offering!
  investor: Wallet!
  investmentId: BigInt! # Protocol's internal investment ID
  amount: BigInt!
  tokenQuantity: BigInt!
  investedAt: BigInt!
  investedTx: Bytes!
  investedBlockNumber: BigInt!
  
  # Representative signing for investment
  actualInvestor: Wallet # The individual who physically made the investment (for entity investments)
  investedOnBehalfOf: Wallet # The entity on whose behalf the investment was made
  isInvestmentDelegated: Boolean! # True if actualInvestor invested on behalf of investedOnBehalfOf
  
  # Status management
  status: InvestmentStatus!
  
  # Countersign data (when status = ACCEPTED)
  countersignedAt: BigInt
  countersignedTx: Bytes
  countersignedBy: Wallet # The individual who physically countersigned
  countersignedOnBehalfOf: Wallet # The entity on whose behalf countersigning happened
  isCountersignDelegated: Boolean # True if countersignedBy signed on behalf of countersignedOnBehalfOf
  
  # Rejection data (when status = REJECTED)
  rejectedAt: BigInt
  rejectedTx: Bytes
  
  # Attestations
  identityUID: Bytes!
  qualificationUID: Bytes!
}

type OffchainInvestment @entity {
  id: ID! # offering-investmentId (compositeId for protocol lookups)
  offering: Offering!
  investor: Wallet!
  investmentId: BigInt! # Protocol's internal investment ID
  amount: BigInt!
  tokenQuantity: BigInt!
  paymentMethod: String!
  referenceId: String!
  recordedAt: BigInt!
  recordedTx: Bytes!
  recordedBlockNumber: BigInt!
  recordedBy: Bytes! # Admin who recorded it
  
  # Status management
  status: OffchainInvestmentStatus!
  
  # Confirmation data (when status = CONFIRMED)
  confirmedAt: BigInt
  confirmedTx: Bytes
  confirmedBy: Bytes
  
  # Cancellation data (when status = CANCELLED)
  cancelledAt: BigInt
  cancelledTx: Bytes
  cancelledBy: Bytes
}

enum OffchainInvestmentStatus {
  PENDING
  CONFIRMED
  CANCELLED
}

# ============ ESCROW ENTITIES ============

type Escrow @entity {
  id: ID! # Escrow address
  address: Bytes!
  seller: Bytes!
  buyer: Bytes
  arbiter: Bytes
  price: BigInt!
  status: EscrowStatus!
  
  # Creation data
  createdAt: BigInt!
  createdAtBlock: BigInt!
  transactionHash: Bytes!
  
  # Lifecycle timestamps
  activatedAt: BigInt
  activatedAtBlock: BigInt
  cancelledAt: BigInt
  cancelledAtBlock: BigInt
  offerAcceptedAt: BigInt
  offerAcceptedAtBlock: BigInt
  fundedAt: BigInt
  fundedAtBlock: BigInt
  disputeRaisedAt: BigInt
  disputeRaisedAtBlock: BigInt
  disputeRaisedBy: Bytes
}

# ============ TOKEN ENTITIES ============

# Interface for all token types (common fields)
interface Token {
  id: ID! # Token address
  name: String!
  symbol: String!
  decimals: Int!
  totalSupply: BigInt!
  admin: Bytes! # The issuer/owner of the token (company's smart account)
  createdAt: BigInt!
  createdTx: Bytes!
  assetType: TokenAssetType!
  tokenCategory: TokenCategory! # High-level category (EQUITY, DEBT, CONVERTIBLE, DERIVATIVE)
  complianceConditions: [Bytes!]! # Compliance conditions used
  
  # Admin state (from TokenAdminFacet)
  paused: Boolean!
  frozenAccounts: [Bytes!]!
  frozenLots: [Bytes!]!
  retired: Boolean! # Token has been retired (soft flag)
  retiredAt: BigInt # Timestamp when retired (null if not retired)
  
  # Transfer conditions (legacy - deprecated, use complianceModules instead)
  transferController: Bytes
  hasTransferConditions: Boolean!
  
  # Compliance Modules
  complianceModules: [TokenComplianceConfig!]!
  
  # Relationships
  lots: [Lot!]!
  offerings: [Offering!]!
}

enum TokenCategory {
  EQUITY      # Represents ownership: ShareClass, MembershipUnit, FundUnit, SPVUnit
  DEBT        # Represents liability: PromissoryNote, Bond, ConvertibleNote
  CONVERTIBLE # Hybrid instruments: SAFE (converts to equity)
  DERIVATIVE  # Options and warrants: EmployeeStockOption, Warrant, StockAppreciationRight
}

# ShareClass tokens (equity shares and membership units)
type ShareClass implements Token @entity {
  id: ID!
  name: String!
  symbol: String!
  decimals: Int!
  totalSupply: BigInt!
  admin: Bytes!
  createdAt: BigInt!
  createdTx: Bytes!
  assetType: TokenAssetType!
  tokenCategory: TokenCategory!
  cfiCode: Bytes # ISO 10962 Classification of Financial Instruments code (6 bytes)
  complianceConditions: [Bytes!]!
  paused: Boolean!
  frozenAccounts: [Bytes!]!
  frozenLots: [Bytes!]!
  retired: Boolean!
  retiredAt: BigInt
  transferController: Bytes
  hasTransferConditions: Boolean!
  complianceModules: [TokenComplianceConfig!]! @derivedFrom(field: "token")
  lots: [Lot!]! @derivedFrom(field: "token")
  offerings: [Offering!]! @derivedFrom(field: "token")
  
  # Metadata URI (from TokenMetadataFacet)
  baseURI: String # Base URI for token metadata
  
  # ShareClass-specific fields (from TokenAdminFacet)
  maxSupply: BigInt! # 0 = unlimited (from TokenAdminFacet)
  
  # Corporate actions (from TokenCorporateActionsFacet)
  splitNum: BigInt! # Cumulative split numerator
  splitDen: BigInt! # Cumulative split denominator
  divNum: BigInt! # Cumulative dividend numerator
  divDen: BigInt! # Cumulative dividend denominator
  totalSplits: Int! # Count of splits applied
  totalDividends: Int! # Count of dividends applied
  isPublic: Boolean! # Whether entity is SEC registered
  
  # Access control (from AccessControlFacet)
  roleMembers: [TokenRoleMember!]! @derivedFrom(field: "token")
  
  # Corporate action history
  corporateActions: [CorporateAction!]! @derivedFrom(field: "token")
  
  # Option grants for this equity token (for fully diluted cap table)
  optionGrants: [OptionGrant!]! @derivedFrom(field: "equityToken")
}

# Token role membership tracking
type TokenRoleMember @entity {
  id: ID! # token-user-role (e.g., "0x123...abc-0x456...def-1")
  token: ShareClass!
  user: Bytes!
  role: Int! # uint8 role ID
  enabled: Boolean!
  grantedAt: BigInt!
  grantedTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

# Corporate action history tracking
type CorporateAction @entity {
  id: ID! # tx-logIndex (e.g., "0x123...abc-5")
  token: ShareClass!
  actionType: CorporateActionType!
  numerator: BigInt! # Split/dividend numerator
  denominator: BigInt! # Split/dividend denominator
  reducesBasis: Boolean # For dividends only, whether cost basis reduces
  timestamp: BigInt!
  tx: Bytes!
}

enum CorporateActionType {
  StockSplit
  StockDividend
}

# Email-gated token claims
type TokenClaim @entity {
  id: ID! # claimId (bytes32)
  token: ShareClass!
  emailHash: Bytes!
  quantity: BigInt!
  expiresAt: BigInt!
  redeemed: Boolean!
  issuer: Bytes!
  recipient: Bytes # null until redeemed
  lotId: Bytes # null until redeemed
  createdAt: BigInt!
  createdTx: Bytes!
  redeemedAt: BigInt # null until redeemed
  redeemedTx: Bytes # null until redeemed
}

# ============ EQUITY COMPENSATION ============

# 409A Valuation tracking for equity tokens
type Valuation409A @entity {
  id: ID! # token-valuationId
  token: ShareClass!
  valuationId: BigInt!
  pricePerShare: BigInt!
  effectiveDate: BigInt!
  expirationDate: BigInt!
  reportHash: Bytes!
  valuationFirm: Bytes # Optional attestation firm
  recordedBy: Bytes!
  recordedAt: BigInt!
  recordedTx: Bytes!
  invalidatedAt: BigInt
  invalidatedTx: Bytes
  isValid: Boolean!
}

# Stock Option grants
type OptionGrant @entity {
  id: ID! # token-grantId
  equityToken: ShareClass! # Token diamond address (named for UI compatibility)
  grantId: BigInt!
  lotId: Bytes! # Associated lot ID
  recipient: Wallet! # Recipient wallet
  optionType: OptionType!
  status: OptionStatus!
  totalShares: BigInt!
  exercisedShares: BigInt!
  strikePrice: BigInt!
  grantDate: BigInt!
  expirationDate: BigInt!
  vestingDuration: BigInt # Optional - may not be in event
  cliffDuration: BigInt # Optional - may not be in event
  earlyExercise: Boolean # Optional - may not be in event
  election83bHash: Bytes
  election83bDeadline: BigInt
  grantedBy: Bytes! # Who granted the option
  grantTx: Bytes!
  blockNumber: BigInt!
  
  # Exercise history
  exercises: [OptionExercise!]! @derivedFrom(field: "grant")
}

enum OptionType {
  ISO
  NSO
}

enum OptionStatus {
  GRANTED
  PARTIALLY_EXERCISED
  FULLY_EXERCISED
  FORFEITED
  EXPIRED
  CANCELLED
}

# Option exercise events
type OptionExercise @entity {
  id: ID! # tx-logIndex
  grant: OptionGrant!
  sharesExercised: BigInt!
  paymentAmount: BigInt!
  paymentToken: Bytes!
  equityLotId: Bytes! # Lot created on equity token
  exercisedAt: BigInt!
  exerciseTx: Bytes!
}

# RSU grants
type RSUGrant @entity {
  id: ID! # rsuPlan-grantId
  rsuPlan: Bytes! # Address of the RSU plan diamond
  grantId: BigInt!
  recipient: Bytes!
  equityToken: ShareClass!
  companyWallet: Wallet
  status: RSUStatus!
  totalShares: BigInt!
  settledShares: BigInt!
  grantDate: BigInt!
  settlementDate: BigInt
  vestingDuration: BigInt!
  cliffDuration: BigInt!
  grantTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
  
  # Settlement history
  settlements: [RSUSettlement!]! @derivedFrom(field: "grant")
}

enum RSUStatus {
  GRANTED
  PARTIALLY_SETTLED
  FULLY_SETTLED
  FORFEITED
  CANCELLED
}

# RSU settlement events
type RSUSettlement @entity {
  id: ID! # tx-logIndex
  grant: RSUGrant!
  sharesSettled: BigInt!
  equityLotId: Bytes! # Lot created on equity token
  settledAt: BigInt!
  settlementTx: Bytes!
}

# Rule 701 company-level tracking
type Rule701Status @entity {
  id: ID! # companyWallet address
  companyWallet: Wallet!
  totalAssets: BigInt!
  assetReportHash: Bytes!
  aggregate12MonthValue: BigInt! # Rolling 12-month grant value
  currentLimit: BigInt! # Max of $1M or 15% of assets
  remainingCapacity: BigInt!
  disclosureRequired: Boolean!
  disclosureHash: Bytes
  disclosureProvidedAt: BigInt
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
  
  # Registered equity tokens
  equityTokens: [Rule701EquityToken!]! @derivedFrom(field: "rule701Status")
  
  # All grants (options and RSUs)
  grants: [Rule701Grant!]! @derivedFrom(field: "rule701Status")
}

type Rule701EquityToken @entity {
  id: ID! # companyWallet-token
  rule701Status: Rule701Status!
  token: ShareClass!
  registeredAt: BigInt!
  registeredTx: Bytes!
}

type Rule701Grant @entity {
  id: ID! # companyWallet-grantId
  rule701Status: Rule701Status!
  internalGrantId: BigInt!
  equityToken: ShareClass!
  grantValue: BigInt!
  grantType: String! # "ISO_option", "NSO_option", "RSU"
  recipient: Bytes!
  sourcePlan: Bytes! # Option/RSU plan address
  grantDate: BigInt!
  grantTx: Bytes!
}

# ============ SAFE TOKENS ============

# SAFE tokens (Simple Agreement for Future Equity)
# COMMENTED OUT - Will implement in Phase 4
# type Safe implements Token @entity {
#   id: ID!
#   name: String!
#   symbol: String!
#   decimals: Int!
#   totalSupply: BigInt!
#   admin: Bytes!
#   creator: Bytes!
#   deployer: Bytes!
#   createdAt: BigInt!
#   createdTx: Bytes!
#   assetType: TokenAssetType!
#   complianceConditions: [Bytes!]!
#   paused: Boolean!
#   frozenAccounts: [Bytes!]!
#   frozenLots: [Bytes!]!
#   transferController: Bytes
#   hasTransferConditions: Boolean!
#   lots: [Lot!]! @derivedFrom(field: "token")
#   offerings: [Offering!]! @derivedFrom(field: "token")
#   
#   # SAFE-specific fields (from TokenSAFEFacet)
#   issuer: Bytes!
#   defaultValuationCap: BigInt! # 0 = no cap
#   defaultDiscountRate: BigInt! # Basis points (e.g., 2000 = 20%)
#   defaultProRataRight: Boolean!
#   defaultTargetEquityToken: Bytes! # Which share class this converts to
#   defaultHasMFN: Boolean! # Most Favored Nation clause
#   
#   # Conversions
#   conversions: [SAFEConversion!]! @derivedFrom(field: "safe")
# }

# Employee Stock Options
# COMMENTED OUT - Will implement in Phase 4
# type EmployeeStockOption implements Token @entity {
#   id: ID!
#   name: String!
#   symbol: String!
#   decimals: Int!
#   totalSupply: BigInt! # Pool size
#   admin: Bytes!
#   creator: Bytes!
#   deployer: Bytes!
#   createdAt: BigInt!
#   createdTx: Bytes!
#   assetType: TokenAssetType!
#   complianceConditions: [Bytes!]!
#   paused: Boolean!
#   frozenAccounts: [Bytes!]!
#   frozenLots: [Bytes!]!
#   transferController: Bytes
#   hasTransferConditions: Boolean!
#   lots: [Lot!]! @derivedFrom(field: "token")
#   offerings: [Offering!]! @derivedFrom(field: "token")
#   
#   # ESO-specific fields (from TokenESOFacet)
#   issuer: Bytes!
#   underlyingShareClass: ShareClass # Which share class these options are for
#   defaultExercisePrice: BigInt!
#   defaultExpirationPeriod: BigInt! # Seconds after grant
#   poolSize: BigInt! # Total options allocated to pool
#   optionsGranted: BigInt! # Options already granted
#   optionsExercised: BigInt! # Options exercised
#   
#   # Grants
#   grants: [ESOGrant!]! @derivedFrom(field: "option")
# }

# Stock Appreciation Rights
# COMMENTED OUT - Will implement in Phase 4
# type StockAppreciationRight implements Token @entity {
#   id: ID!
#   name: String!
#   symbol: String!
#   decimals: Int!
#   totalSupply: BigInt! # Pool size
#   admin: Bytes!
#   deployer: Bytes!
#   createdAt: BigInt!
#   createdTx: Bytes!
#   assetType: TokenAssetType!
#   complianceConditions: [Bytes!]!
#   paused: Boolean!
#   frozenAccounts: [Bytes!]!
#   frozenLots: [Bytes!]!
#   transferController: Bytes
#   hasTransferConditions: Boolean!
#   lots: [Lot!]! @derivedFrom(field: "token")
#   offerings: [Offering!]! @derivedFrom(field: "token")
#   
#   # SAR-specific fields (from TokenSARFacet)
#   issuer: Bytes!
#   underlyingShareClass: ShareClass # Which share class these SARs reference
#   basePrice: BigInt! # Base price for appreciation calculation
#   settlementType: String! # "Cash" or "Shares"
#   poolSize: BigInt! # Total SARs allocated to pool
#   sarsGranted: BigInt! # SARs already granted
#   sarsExercised: BigInt! # SARs exercised
#   
#   # Grants
#   grants: [SARGrant!]! @derivedFrom(field: "sar")
# }

enum TokenAssetType {
  ShareClass # Corporate common/preferred shares
  MembershipUnit # LLC/DAO membership units
  UnitInterest # LP unit interests (for investment vehicles)
  Safe # Simple Agreement for Future Equity
  PromissoryNote # Debt instrument (loans, bonds, notes)
  DaoToken # DAO governance token
  TokenizedAsset # Tokenized real-world asset
  # Future token types (commented out until implemented):
  # EmployeeStockOption
  # Warrant
  # StockAppreciationRight
}

# SAFE Token Type
type Safe implements Token @entity {
  # Token interface fields
  id: ID! # Token address
  name: String!
  symbol: String!
  decimals: Int!
  totalSupply: BigInt!
  creator: Bytes! # Kept for backwards compatibility
  admin: Bytes!
  deployer: Bytes!
  createdAt: BigInt!
  createdTx: Bytes!
  assetType: TokenAssetType!
  cfiCode: Bytes # ISO 10962 CFI code (6 bytes)
  tokenCategory: TokenCategory!
  
  # Compliance
  complianceConditions: [Bytes!]! # Compliance conditions used
  
  # Admin state
  paused: Boolean!
  frozenAccounts: [Bytes!]!
  frozenLots: [Bytes!]!
  retired: Boolean!
  retiredAt: BigInt
  transferController: Bytes
  hasTransferConditions: Boolean!
  complianceModules: [TokenComplianceConfig!]! @derivedFrom(field: "token")
  lots: [Lot!]! @derivedFrom(field: "token")
  offerings: [Offering!]! @derivedFrom(field: "token")
  
  # Metadata URI (from TokenMetadataFacet)
  baseURI: String # Base URI for token metadata
  
  # SAFE-specific fields
  defaultValuationCap: BigInt! # Default valuation cap (0 = uncapped)
  defaultDiscountRate: Int! # Default discount rate in basis points
  defaultTargetEquityToken: Bytes! # Default ShareClass to convert into
  defaultProRataRight: Boolean! # Default pro-rata participation rights
  defaultHasMFN: Boolean! # Default Most Favored Nation clause
  
  # Statistics
  totalInvested: BigInt!
  totalConverted: BigInt!
  lotsConverted: Int!
  
  # Conversions
  conversions: [SAFEConversion!]! @derivedFrom(field: "safe")
}

# SAFE Conversion tracking
type SAFEConversion @entity {
  id: ID! # tx-hash-logIndex
  safe: Safe!
  safeLot: Lot! # The SAFE lot being converted
  investor: Bytes!
  investmentAmount: BigInt!
  sharesIssued: BigInt!
  effectivePrice: BigInt!
  targetShareClass: Bytes! # ShareClass token address
  equityLotId: Bytes! # The new equity lot created
  conversionNote: String!
  convertedAt: BigInt!
  convertedTx: Bytes!
  blockNumber: BigInt!
  logIndex: BigInt!
}

# ============ PROMISSORY NOTE TOKEN TYPE ============

# Promissory Note Token Type (Debt Instrument)
type PromissoryNote implements Token @entity {
  # Token interface fields
  id: ID! # Token address
  name: String!
  symbol: String!
  decimals: Int!
  totalSupply: BigInt!
  creator: Bytes! # Kept for backwards compatibility
  admin: Bytes!
  deployer: Bytes!
  createdAt: BigInt!
  createdTx: Bytes!
  assetType: TokenAssetType!
  cfiCode: Bytes # ISO 10962 CFI code (6 bytes)
  tokenCategory: TokenCategory!
  
  # Compliance
  complianceConditions: [Bytes!]! # Compliance conditions used
  
  # Admin state
  paused: Boolean!
  frozenAccounts: [Bytes!]!
  frozenLots: [Bytes!]!
  retired: Boolean!
  retiredAt: BigInt
  transferController: Bytes
  hasTransferConditions: Boolean!
  complianceModules: [TokenComplianceConfig!]! @derivedFrom(field: "token")
  lots: [Lot!]! @derivedFrom(field: "token")
  offerings: [Offering!]! @derivedFrom(field: "token")
  
  # Metadata URI (from TokenMetadataFacet)
  baseURI: String # Base URI for token metadata
  uri: String # Deprecated: use baseURI instead
  
  # Debt-specific fields
  principalAmount: BigInt! # Original principal (same as totalSupply for debt)
  interestRate: Int! # Annual rate in basis points (500 = 5%, 0 = no interest)
  issuanceDate: BigInt! # When debt was issued
  maturityDate: BigInt! # When repayment is due
  paymentCurrency: Bytes! # Currency for payments (address(0) for ETH)
  paymentType: DebtPaymentType! # BULLET, AMORTIZING, INTEREST_ONLY
  isSubordinated: Boolean! # True if subordinated debt (e.g., founder notes)
  gracePeriodDays: Int! # Days after maturity before default
  
  # Debtor tracking
  debtor: Bytes! # Company/borrower wallet address
  creditor: Bytes! # Token holder (lender) wallet address
  
  # Payment tracking
  totalPaid: BigInt!
  principalPaid: BigInt!
  interestPaid: BigInt!
  outstandingBalance: BigInt!
  
  # Status
  status: DebtStatus!
  isMatured: Boolean!
  isDefaulted: Boolean!
  defaultedAt: BigInt
  
  # Relationships
  payments: [DebtPayment!]! @derivedFrom(field: "note")
}

enum DebtPaymentType {
  BULLET # Single payment at maturity
  AMORTIZING # Regular principal + interest payments
  INTEREST_ONLY # Regular interest, principal at maturity
}

enum DebtStatus {
  ACTIVE # Debt is active and accruing
  PAID_OFF # Fully repaid
  DEFAULTED # In default
  EXTENDED # Maturity extended
}

# Debt Payment tracking
type DebtPayment @entity {
  id: ID! # tx-hash-logIndex
  note: PromissoryNote!
  payer: Bytes! # Who made the payment
  amount: BigInt! # Total payment amount
  principalPortion: BigInt! # Amount applied to principal
  interestPortion: BigInt! # Amount applied to interest
  remainingBalance: BigInt! # Outstanding balance after payment
  paidAt: BigInt!
  paidTx: Bytes!
  blockNumber: BigInt!
  logIndex: BigInt!
}

# ============ FUTURE TOKEN TYPES ============

# FUTURE: ESO Grant tracking (uncomment when implementing ESO tokens)
# type ESOGrant @entity {
#   id: ID! # option-grant-index
#   option: EmployeeStockOption!
#   grantee: Wallet!
#   lot: Lot! # The ESO lot for this grant
#   quantity: BigInt!
#   exercisePrice: BigInt!
#   grantedAt: BigInt!
#   cliffDate: BigInt!
#   expirationDate: BigInt!
#   vestedAmount: BigInt!
#   exercisedAmount: BigInt!
#   isRevoked: Boolean!
#   revokedAt: BigInt
# }

# FUTURE: SAR Grant tracking (uncomment when implementing SAR tokens)
# type SARGrant @entity {
#   id: ID! # sar-grant-index
#   sar: StockAppreciationRight!
#   grantee: Wallet!
#   lot: Lot! # The SAR lot for this grant
#   quantity: BigInt!
#   basePrice: BigInt!
#   grantedAt: BigInt!
#   cliffDate: BigInt!
#   expirationDate: BigInt!
#   vestedAmount: BigInt!
#   exercisedAmount: BigInt!
#   isRevoked: Boolean!
#   revokedAt: BigInt
# }

# Transfer Conditions (vesting, lockups, etc.)
type TransferCondition @entity {
  id: ID! # token-condition-index
  token: Token! # Can apply to any token type
  conditionType: TransferConditionType!
  account: Bytes!
  lot: Lot # Optional: specific to a lot
  
  # Vesting-specific fields
  startDate: BigInt
  cliffDate: BigInt
  endDate: BigInt
  totalAmount: BigInt
  claimedAmount: BigInt!
  
  # State
  revoked: Boolean!
  revokedAt: BigInt
  
  createdAt: BigInt!
  createdTx: Bytes!
}

enum TransferConditionType {
  Vesting
  Lockup
  Custom
}

# ============ COMPLIANCE MODULES ============

# Compliance module registry - tracks all compliance modules used across tokens
type ComplianceModule @entity {
  id: ID! # module-address
  address: Bytes!
  name: String!
  version: String!
  moduleType: String! # "HoldingPeriod", "VolumeLimit", "AffiliateStatus", "Vesting", "Lockup", "Custom"
  firstUsedAt: BigInt!
  firstUsedTx: Bytes!
  
  # Relationships
  tokens: [TokenComplianceConfig!]! @derivedFrom(field: "module")
}

# Token-level compliance configuration - which modules are active for each token
type TokenComplianceConfig @entity {
  id: ID! # token-module
  token: Token!
  module: ComplianceModule!
  isGlobal: Boolean! # True if applies to all lots, false if lot-specific
  addedAt: BigInt!
  addedTx: Bytes!
  removedAt: BigInt
  removedTx: Bytes
  isActive: Boolean! # False if removed
}

# Lot-specific module assignment (overrides or additions to global modules)
type LotComplianceConfig @entity {
  id: ID! # lot-module
  lot: Lot!
  module: ComplianceModule!
  addedAt: BigInt!
  addedTx: Bytes!
}

# ============ MODULE-SPECIFIC ENTITIES ============

# Holding Period Module - tracks acquisition dates and required holding periods
type HoldingPeriodConfig @entity {
  id: ID! # token-lotId-holder
  token: Token!
  lotId: Bytes! # bytes32 lot identifier
  holder: Bytes!
  module: ComplianceModule! # Reference to the HoldingPeriodModule instance
  holdingPeriod: BigInt! # Required holding period in seconds (from token-level config)
  acquisitionDate: BigInt! # When holder acquired this lot
  unlockDate: BigInt! # Calculated: acquisitionDate + holdingPeriod
  isUnlocked: Boolean! # True if current time >= unlockDate
  
  # Tracking
  createdAt: BigInt!
  createdTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

# Minimum balance configuration for a token
type MinimumBalanceConfig @entity {
  id: ID! # token address (one config per token)
  token: Token!
  module: ComplianceModule! # Reference to the MinimumBalanceModule instance
  minimumBalance: BigInt! # Minimum balance required (0 = no minimum)
  autoExemptRoles: Bytes! # Bitmask of auto-exempt roles (e.g., admin/GP)
  
  # Tracking
  createdAt: BigInt!
  createdTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

# Exemption from minimum balance for a specific holder
type MinimumBalanceExemption @entity {
  id: ID! # token-holder
  token: Token!
  holder: Bytes!
  isExempt: Boolean!
  
  # Tracking
  createdAt: BigInt!
  createdTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

# Volume Limit Module - tracks rolling volume limits for affiliates
type VolumeLimitConfig @entity {
  id: ID! # token-holder
  token: Token!
  holder: Bytes!
  module: ComplianceModule! # Reference to the VolumeLimitModule instance
  
  # Configuration (from token-level settings)
  limitBps: Int! # Basis points (100 = 1%, 10000 = 100%)
  windowSeconds: BigInt! # Time window for volume tracking
  
  # Current window state
  currentWindowStart: BigInt! # When current window started
  currentVolume: BigInt! # Cumulative volume in current window
  lastTransferAt: BigInt # Last time volume was recorded
  
  # Tracking
  createdAt: BigInt!
  createdTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

# Affiliate Status Module - tracks which holders are affiliates
type AffiliateStatus @entity {
  id: ID! # token-holder
  token: Token!
  holder: Bytes!
  module: ComplianceModule! # Reference to the AffiliateStatusModule instance
  isAffiliate: Boolean!
  affiliateSince: BigInt # When holder became affiliate (null if never was)
  affiliateUntil: BigInt # When holder stopped being affiliate (null if currently is)
  
  # History tracking
  statusChanges: [AffiliateStatusChange!]! @derivedFrom(field: "affiliateStatus")
  
  # Tracking
  createdAt: BigInt!
  createdTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

# History of affiliate status changes
type AffiliateStatusChange @entity {
  id: ID! # tx-hash-logIndex
  affiliateStatus: AffiliateStatus!
  becameAffiliate: Boolean! # True if became affiliate, false if revoked
  changedAt: BigInt!
  changedTx: Bytes!
}

# Lockup Compliance Module - tracks time-based lockups per lot
type LockupConfig @entity {
  id: ID! # lotId (bytes32 as hex string)
  lotId: Bytes! # bytes32 lot identifier
  unlockTime: BigInt! # Unix timestamp when lot becomes transferable
  
  # Tracking
  createdAt: BigInt!
  createdTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

# Vesting Compliance Module - tracks vesting schedules per lot
type VestingConfig @entity {
  id: ID! # lotId (bytes32 as hex string)
  lotId: Bytes! # bytes32 lot identifier
  holder: Bytes! # Token holder address
  totalBasisPoints: BigInt! # Percentage of lot to vest (10000 = 100%)
  releasedBasisPoints: BigInt! # Percentage already released
  startTime: BigInt! # Vesting start timestamp
  duration: BigInt! # Total vesting duration in seconds
  cliffDuration: BigInt! # Cliff period in seconds
  revocable: Boolean! # Whether the schedule can be revoked
  revoked: Boolean! # Whether the schedule has been revoked
  
  # Tracking
  createdAt: BigInt!
  createdTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

type Lot @entity {
  id: ID! # token-lotId
  token: Token! # Can reference any token type via interface
  lotId: BigInt!
  owner: Wallet!
  quantity: BigInt! # Raw quantity (before corporate actions). To get real quantity: quantity * token.splitNum * token.divNum / (token.splitDen * token.divDen)
  costBasis: BigInt! # Total cost basis for this lot (total investment amount, not per-token). Use paymentDecimals to convert to display value.
  acquisitionDate: BigInt!
  createdAt: BigInt! # Alias for acquisitionDate
  acquiredFrom: Bytes!
  parentLotId: BigInt # For lot splits/transfers
  assetId: String # Token identifier
  paymentCurrency: Bytes # Currency used for acquisition
  paymentDecimals: Int # Decimals of the payment currency
  customId: BigInt # Custom ID for user-friendly lot identification
  uri: String # URI of the lot
  isValid: Boolean! # Whether the lot is active (false if burned/invalidated)
  data: Bytes # Additional data associated with the lot
  transferType: String # Transfer type (INTERNAL, SALE, GIFT, INHERITANCE, INCOME)
  metadata: String
  
  # Adjustment history
  adjustedFrom: Lot # Reference to parent lot if this was created via adjustment
  adjustments: [LotAdjustment!]! @derivedFrom(field: "lot")
  
  # State
  frozen: Boolean!
  frozenAt: BigInt
  
  # Compliance
  lotSpecificModules: [LotComplianceConfig!]! @derivedFrom(field: "lot") # Lot-specific compliance modules (in addition to token's global modules)
  
  # Type-specific references (optional - uncomment as needed)
  # esoGrant: ESOGrant # If this is an ESO grant lot
  # sarGrant: SARGrant # If this is a SAR grant lot
  # safeConversion: SAFEConversion # If this lot was created from SAFE conversion
}

type LotAdjustment @entity {
  id: ID! # tx-hash-logIndex
  oldLot: Lot!
  newLot: Lot!
  operator: Bytes!
  owner: Bytes!
  newQuantity: BigInt!
  newCostBasis: BigInt!
  paymentCurrency: Bytes!
  acquisitionDate: BigInt!
  uri: String!
  data: Bytes!
  reason: String!
  transferType: String!
  adjustedCostBasis: BigInt! # The delta in cost basis
  timestamp: BigInt!
  transaction: Bytes!
  lot: Lot! # For reverse lookup
}

type CustomIdUpdate @entity {
  id: ID! # tx-hash-logIndex
  lot: Lot!
  oldCustomId: BigInt!
  newCustomId: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

# ============ PRE-APPROVED TERMS (Offering-specific) ============

# Interface for all pre-approved term types
interface PreApprovedTerms {
  id: ID! # offering-investor
  offering: Offering!
  investor: Bytes!
  encodedTerms: Bytes! # Raw encoded data
  assetType: TokenAssetType!
  setAt: BigInt!
  setTx: Bytes!
  setBy: Bytes! # Admin who set the terms
  cleared: Boolean!
  clearedAt: BigInt
  clearedTx: Bytes
  clearedBy: Bytes
}

# SAFE-specific pre-approved terms
type SafePreApprovedTerms implements PreApprovedTerms @entity {
  id: ID! # offering-investor
  offering: Offering!
  investor: Bytes!
  encodedTerms: Bytes!
  assetType: TokenAssetType!
  setAt: BigInt!
  setTx: Bytes!
  setBy: Bytes!
  cleared: Boolean!
  clearedAt: BigInt
  clearedTx: Bytes
  clearedBy: Bytes
  
  # SAFE-specific decoded fields
  valuationCap: BigInt! # 0 = uncapped
  discountRate: Int! # Basis points (e.g., 2000 = 20%)
  interestRate: Int! # Basis points (e.g., 500 = 5%)
  maturityDate: BigInt! # Unix timestamp, 0 = no maturity
}

# ============ COMPLIANCE (ComplianceStorage-based) ============

type KYCStatus @entity {
  id: ID! # offering-address-wallet-address (e.g., "0x123...abc-0x456...def")
  offering: Offering!
  wallet: Wallet!
  verified: Boolean!
  expirationTime: BigInt!
  verifiedBy: Bytes!
  updatedAt: BigInt!
  updatedTx: Bytes!
  revoked: Boolean!
  revokedAt: BigInt
  revokedTx: Bytes
  revokedBy: Bytes
}

type InvestorClassification @entity {
  id: ID! # offering-address-wallet-address-classification (e.g., "0x123...abc-0x456...def-ACCREDITED_INVESTOR")
  offering: Offering!
  wallet: Wallet!
  classification: String! # Classification string (e.g., "ACCREDITED_INVESTOR", "NON_ACCREDITED_INVESTOR")
  classificationHash: Bytes! # bytes32 hash for compatibility
  addedAt: BigInt!
  addedTx: Bytes!
  addedBy: Bytes!
  revoked: Boolean!
  revokedAt: BigInt
  revokedTx: Bytes
  revokedBy: Bytes
}

# Deprecated: Old EAS-based attestations (kept for backward compatibility)
type Attestation @entity {
  id: ID! # attestation UID
  schema: Bytes! # Schema UID
  attester: Bytes!
  wallet: Wallet! # The wallet this attestation is about
  data: Bytes!
  createdAt: BigInt!
  expiresAt: BigInt
  revoked: Boolean!
  revokedAt: BigInt
  
  # Decoded fields for unified investor schema: (address offering, bool isVerified, bytes32[] classifications)
  offering: Bytes # Offering address (0x0 = universal/global attestation)
  isVerified: Boolean # KYC/identity verification status
  classifications: [Bytes!]! # Investor classifications (e.g., ACCREDITED, NON_ACCREDITED, SOPHISTICATED)
}

# ============ FACET REGISTRY ============

type Facet @entity {
  id: ID! # Facet address
  name: String!
  version: BigInt!
  selectors: [String!]!
  createdAt: BigInt!
  createdTx: Bytes!
  deploymentSalt: Bytes # Salt used for CREATE2 deployment (if deployed via registry)
  removed: Boolean!
  removedAt: BigInt
  removedTx: Bytes
}

type FacetRegistryEvent @entity {
  id: ID! # tx-logIndex
  eventType: FacetRegistryEventType!
  facet: Bytes!
  facetName: String!
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
  
  # For FacetDeployed events
  deploymentSalt: Bytes
  selectors: [String!]
}

enum FacetRegistryEventType {
  REGISTERED
  REMOVED
  DEPLOYED
}

# ============ INSTALLED FACETS (Diamond Config Tracking) ============

# Tracks which facets are currently installed on a diamond
type InstalledFacet @entity {
  id: ID! # diamond-facetAddress (e.g., "0xwallet-0xfacet")
  diamond: Diamond!
  facetAddress: Bytes!
  facetName: String # Resolved from registry if known
  selectors: [String!]! # Function selectors routed to this facet
  action: FacetCutAction! # How it was installed (ADD, REPLACE)
  installedAt: BigInt!
  installedTx: Bytes!
  installedBlock: BigInt!
  
  # Version tracking (resolved from registry)
  version: BigInt # Null if facet not in registry
  
  # Current state
  isActive: Boolean! # False if removed
  removedAt: BigInt
  removedTx: Bytes
}

# Historical record of all diamond cuts
type DiamondCutEvent @entity {
  id: ID! # tx-logIndex
  diamond: Diamond!
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
  
  # Cut details
  facetAddress: Bytes!
  action: FacetCutAction!
  selectors: [String!]!
  
  # Initialization (if any)
  initAddress: Bytes
  initCalldata: Bytes
}

enum FacetCutAction {
  ADD
  REPLACE
  REMOVE
}

# ============ PAYMENT TOKENS ============

# Generic ERC20 token entity (reusable across offerings, factories, etc.)
type PaymentToken @entity {
  id: ID! # Token address
  address: Bytes!
  symbol: String!
  decimals: Int!
  name: String!
  
  # Where this token is used
  factoryConfigs: [FactoryPaymentTokenConfig!]! @derivedFrom(field: "paymentToken")
  
  createdAt: BigInt!
  createdTx: Bytes!
}

# ============ FACTORY PAYMENT TRACKING ============

type FactoryPaymentConfig @entity {
  id: ID! # factory-address
  factory: Bytes!
  factoryType: FactoryType! # TOKEN, OFFERING, WALLET
  feeRecipient: Bytes!
  paymentsEnabled: Boolean!
  deploymentCount: BigInt!
  
  # Payment token configurations
  paymentTokens: [FactoryPaymentTokenConfig!]! @derivedFrom(field: "factoryConfig")
  
  # Payments collected
  payments: [FactoryPayment!]! @derivedFrom(field: "factory")
  
  createdAt: BigInt!
  createdTx: Bytes!
}

# Factory-specific configuration for a payment token
type FactoryPaymentTokenConfig @entity {
  id: ID! # factory-token
  factoryConfig: FactoryPaymentConfig!
  paymentToken: PaymentToken! # Reference to the token entity
  feeAmount: BigInt!
  isActive: Boolean!
  totalCollected: BigInt!
  
  configuredAt: BigInt!
  configuredTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

type FactoryPayment @entity {
  id: ID! # tx-logIndex
  factory: FactoryPaymentConfig!
  payer: Bytes!
  paymentToken: Bytes!
  amount: BigInt!
  deploymentType: String! # "Token", "Offering", "Wallet"
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

# Factory payment discount tracking
type FactoryPaymentDiscount @entity {
  id: ID! # factory-user
  factory: Bytes!
  user: Bytes!
  discountBasisPoints: BigInt! # 10000 = 100% discount (free)
  setAt: BigInt!
  setTx: Bytes!
  lastUpdatedAt: BigInt!
  lastUpdatedTx: Bytes!
}

enum FactoryType {
  DIAMOND
  TOKEN
  OFFERING
  WALLET
}

# ============ ROFR (Right of First Refusal) ENTITIES ============

type ROFRTransferRequest @entity {
  id: ID! # module-requestId
  module: Bytes! # ROFR module address
  token: Token! # Token being transferred
  requestId: BigInt!
  seller: Bytes!
  proposedBuyer: Bytes!
  currentBuyer: Bytes! # May differ if ROFR exercised
  amount: BigInt!
  pricePerToken: BigInt!
  paymentToken: Bytes!
  status: ROFRRequestStatus!
  rofrExpiresAt: BigInt # When ROFR period ends
  rofrExercisedBy: Bytes # Who exercised ROFR (if any)
  rejectionReason: String
  createdAt: BigInt!
  createdTx: Bytes!
  updatedAt: BigInt!
  updatedTx: Bytes!
  completedAt: BigInt
  completedTx: Bytes
}

enum ROFRRequestStatus {
  PENDING
  ROFR_PERIOD
  APPROVED
  ROFR_EXERCISED
  REJECTED
  COMPLETED
  CANCELLED
}

# ============ DEFI INTEGRATION ENTITIES ============

# Registered DeFi vault (e.g., Morpho, Aave)
type DeFiVault @entity {
  id: ID! # vault-walletAddress (e.g., "0xvault-0xwallet")
  vault: Bytes! # ERC-4626 vault address
  wallet: Wallet! # Wallet that registered this vault
  asset: Bytes! # Underlying asset address
  name: String!
  
  # All positions in this vault for this wallet
  positions: [VaultPosition!]! @derivedFrom(field: "vault")
  
  registeredAt: BigInt!
  registeredTx: Bytes!
}

# Individual vault position
type VaultPosition @entity {
  id: ID! # wallet-investmentId
  wallet: Wallet!
  vault: DeFiVault!
  investmentId: BigInt! # ID from InvestmentFacet
  
  # Position state
  sharesBalance: BigInt!
  costBasis: BigInt! # Total deposited
  currentValue: BigInt! # Latest valuation
  unrealizedGain: BigInt! # currentValue - costBasis (signed, stored as BigInt)
  lastUpdated: BigInt!
  
  # Status
  isActive: Boolean! # False when fully exited
  exitedAt: BigInt
  exitedTx: Bytes
  totalRealizedGain: BigInt! # Sum of all realized gains from withdrawals
  
  # History
  deposits: [VaultDeposit!]! @derivedFrom(field: "position")
  withdrawals: [VaultWithdrawal!]! @derivedFrom(field: "position")
  valuationUpdates: [VaultValuationUpdate!]! @derivedFrom(field: "position")
  
  createdAt: BigInt!
  createdTx: Bytes!
}

# Vault deposit event
type VaultDeposit @entity {
  id: ID! # tx-logIndex
  position: VaultPosition!
  wallet: Wallet!
  vaultAddress: Bytes!
  asset: Bytes!
  assetsDeposited: BigInt!
  sharesReceived: BigInt!
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

# Vault withdrawal event
type VaultWithdrawal @entity {
  id: ID! # tx-logIndex
  position: VaultPosition!
  wallet: Wallet!
  vaultAddress: Bytes!
  sharesRedeemed: BigInt!
  assetsReceived: BigInt!
  realizedGain: BigInt! # Can be negative for losses
  isFullExit: Boolean!
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

# Vault valuation update event
type VaultValuationUpdate @entity {
  id: ID! # tx-logIndex
  position: VaultPosition!
  wallet: Wallet!
  vaultAddress: Bytes!
  oldValue: BigInt!
  newValue: BigInt!
  timestamp: BigInt!
  tx: Bytes!
  blockNumber: BigInt!
}

# ============ REDEMPTION CONTROL ENTITIES ============

enum RedemptionStatus {
  PENDING
  QUEUED
  PARTIAL
  FULFILLED
  CANCELLED
}

enum SuspensionReason {
  MARKET_STRESS
  LIQUIDITY
  NAV_UNCERTAINTY
  REGULATORY
  OTHER
}

# Redemption request from an investor
type RedemptionRequest @entity {
  id: ID! # wallet-requestId
  wallet: Wallet!
  requestId: BigInt!
  investor: Bytes!
  sharesRequested: BigInt!
  sharesFulfilled: BigInt!
  sharesRemaining: BigInt!
  amountPaid: BigInt!
  navPerShare: BigInt!
  status: RedemptionStatus!
  requestedAt: BigInt!
  eligibleAt: BigInt!
  processedAt: BigInt
  cancelledAt: BigInt
  cancelReason: String
  transactionHash: Bytes!
}

# Suspension event
type RedemptionSuspension @entity {
  id: ID! # wallet-timestamp
  wallet: Wallet!
  reason: SuspensionReason!
  description: String!
  suspendedBy: Bytes!
  suspendedAt: BigInt!
  resumedAt: BigInt
  resumedBy: Bytes
  transactionHash: Bytes!
}

# Side pocket for illiquid assets
type SidePocket @entity {
  id: ID! # wallet-sidePocketId
  wallet: Wallet!
  sidePocketId: BigInt!
  investmentId: BigInt!
  reason: String!
  isActive: Boolean!
  createdAt: BigInt!
  distributedAt: BigInt
  totalDistributed: BigInt
  recipientCount: BigInt
  createdTx: Bytes!
  distributedTx: Bytes
}

# Gate period summary
type GatePeriod @entity {
  id: ID! # wallet-periodStart
  wallet: Wallet!
  periodStart: BigInt!
  periodEnd: BigInt!
  gateLimit: BigInt!
  totalFulfilled: BigInt!
  transactionHash: Bytes!
}
